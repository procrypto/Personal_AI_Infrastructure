/**
 * useAutopilotTokensWithPrices
 *
 * Combines autopilot token lists with NATS market data to provide
 * live price and change data. Follows the same pattern as useAutopilotPositions.
 */

import { useMemo } from "react";
import { useGlobalStore, useShallow } from "@/store/memoryStore/useGlobalStore";
import type { AutopilotWatchedToken } from "@/store/memoryStore/slices/autopilot-store/types";

/**
 * Token with enriched price data from NATS.
 * Uses undefined for missing data to match AutopilotWatchedToken optionals.
 */
export interface AutopilotTokenWithPrices extends AutopilotWatchedToken {
  priceUsd: number | undefined;
  change1h: number | undefined;
}

/**
 * Token lists with enriched price data.
 */
export interface AutopilotTokenListWithPrices {
  watchlist: AutopilotTokenWithPrices[];
  trending: AutopilotTokenWithPrices[];
  whales: AutopilotTokenWithPrices[];
}

/**
 * Hook to get autopilot token lists with live price data from NATS market data.
 */
export const useAutopilotTokensWithPrices =
  (): AutopilotTokenListWithPrices => {
    // Get token lists from autopilot store
    const tokenList = useGlobalStore(
      useShallow(state => state.autopilot.tokenList)
    );

    // Get market data map and SOL price for USD conversion
    const marketDataMap = useGlobalStore(
      useShallow(state => state.websocketMessages.market_data.data)
    );

    // SOL price is stored as string
    const solPriceUsdStr = useGlobalStore(state => state.solanaPrice.usd);
    const solPriceUsd = solPriceUsdStr ? parseFloat(solPriceUsdStr) : undefined;

    // DIAGNOSTIC: Compare token mints vs marketDataMap keys
    const totalTokens =
      tokenList.watchlist.length +
      tokenList.trending.length +
      tokenList.whales.length;
    if (totalTokens > 0) {
      const marketDataKeys = Object.keys(marketDataMap);
      const allTokenMints = [
        ...tokenList.watchlist,
        ...tokenList.trending,
        ...tokenList.whales,
      ].map(t => t.mint);
      const matchCount = allTokenMints.filter(
        mint => marketDataMap[mint]
      ).length;

      console.log("[Autopilot] ========== TOKEN DATA DEBUG ==========");
      console.log(
        "[Autopilot] Token mints (first 3):",
        allTokenMints.slice(0, 3)
      );
      console.log(
        "[Autopilot] MarketData keys (first 3):",
        marketDataKeys.slice(0, 3)
      );
      console.log(
        "[Autopilot] MATCH RESULT:",
        matchCount,
        "/",
        totalTokens,
        "tokens found in marketDataMap"
      );
      console.log("[Autopilot] =====================================");
    }

    // Enrich a single token with price data
    const enrichToken = useMemo(() => {
      return (token: AutopilotWatchedToken): AutopilotTokenWithPrices => {
        const mintData = marketDataMap[token.mint];

        if (!mintData || mintData.size === 0) {
          return {
            ...token,
            priceUsd: undefined,
            change1h: undefined,
          };
        }

        // Get the latest market data
        const latestMarketData = Array.from(mintData.values())[0];

        // DIAGNOSTIC: Log what's inside the market data for first token
        if (token.symbol === "BONK" || token.mint.startsWith("DezX")) {
          console.log("[Autopilot] enrichToken for", token.symbol, ":");
          console.log("  mintData size:", mintData.size);
          console.log("  latestMarketData:", latestMarketData);
          console.log("  price_sol:", latestMarketData?.price_sol);
          console.log("  trading_stats_1h:", latestMarketData?.trading_stats_1h);
        }

        if (!latestMarketData?.price_sol) {
          return {
            ...token,
            priceUsd: undefined,
            change1h: undefined,
          };
        }

        // price_sol is a number in TokenMarketData, convert to USD
        const priceSol = latestMarketData.price_sol;
        const priceUsd =
          typeof priceSol === "number" &&
          !isNaN(priceSol) &&
          solPriceUsd &&
          !isNaN(solPriceUsd)
            ? priceSol * solPriceUsd
            : undefined;

        // Calculate 1h change from trading_stats_1h if available
        let change1h: number | undefined = undefined;
        const stats1h = latestMarketData.trading_stats_1h;
        if (
          stats1h?.earliest_price_sol &&
          typeof priceSol === "number" &&
          !isNaN(priceSol)
        ) {
          const earliestPrice = parseFloat(stats1h.earliest_price_sol);
          if (!isNaN(earliestPrice) && earliestPrice !== 0) {
            change1h = ((priceSol - earliestPrice) / earliestPrice) * 100;
          }
        }

        return {
          ...token,
          priceUsd,
          change1h,
        };
      };
    }, [marketDataMap, solPriceUsd]);

    // Enrich all token lists
    return useMemo(() => {
      return {
        watchlist: tokenList.watchlist.map(enrichToken),
        trending: tokenList.trending.map(enrichToken),
        whales: tokenList.whales.map(enrichToken),
      };
    }, [tokenList, enrichToken]);
  };
