#!/usr/bin/env node
/**
 * CLI Interface
 *
 * Simple CLI for configuring and running the analysis autopilot.
 */

import { configStore } from './config/index.js';
import type { TokenSource } from './config/types.js';
import { templates, listTemplates, getTemplate, getTemplateSummary, RuleEngine } from './rules/index.js';
import { localApi } from './api/index.js';
import { paperTracker, createTrigger, createAutoSourceManager, magicExits, magicBuy, marketFilter, MarketFilter } from './trading/index.js';
import { wsServer, type PositionData, type SignalData, type MarketStatusData, type StatsData, type WatchedToken, type TokenListData, type ConfigData, type AutopilotCommand, type StrategiesData, type StrategyInfo } from './websocket-server.js';
import { createSignalPipeline } from './signal/integration.js';

// Wrapped SOL mint for market filter
const SOL_MINT = 'So11111111111111111111111111111111111111112';

const HELP = `
Token Analysis Autopilot CLI

Commands:
  watch <mint> [symbol]  Add token to watchlist
  unwatch <mint>         Remove token from watchlist
  list                   List watchlist

  sources                Show auto-source status (trending, whales)
  sources on|off         Enable/disable auto-sources
  sources trending on|off
  sources whales on|off

  templates              List available rule templates
  use <template>         Add a template to active rules
  remove <rule-id>       Remove a rule set
  rules                  List active rules

  config                 Show current config
  mode <paper|live>      Set trigger mode
  size <sol>             Set default position size

  filter                 Show market filter status
  filter on|off          Enable/disable market filter

  analyze <mint>         Analyze a single token (with trigger)
  run                    Start analysis loop (parallel mode)
  run --new-engine       Start with new signal pipeline only

  status                 Live portfolio overview with P&L
  trades                 List all paper trades
  stats                  Show trading stats
  close <mint>           Close open position for mint
  reset                  Clear all trading data

  help                   Show this help
`;

async function main() {
  const args = process.argv.slice(2);
  const command = args[0]?.toLowerCase();

  await configStore.load();
  await paperTracker.load();

  switch (command) {
    case 'watch': {
      const mint = args[1];
      const symbol = args[2];
      if (!mint) {
        console.error('Usage: watch <mint> [symbol]');
        process.exit(1);
      }
      configStore.addToWatchlist(mint, symbol);
      await configStore.save();
      console.log(`Added ${symbol || mint} to watchlist`);
      break;
    }

    case 'unwatch': {
      const mint = args[1];
      if (!mint) {
        console.error('Usage: unwatch <mint>');
        process.exit(1);
      }
      if (configStore.removeFromWatchlist(mint)) {
        await configStore.save();
        console.log(`Removed ${mint} from watchlist`);
      } else {
        console.log('Token not found in watchlist');
      }
      break;
    }

    case 'list': {
      const watchlist = configStore.getWatchlist();
      if (watchlist.length === 0) {
        console.log('Watchlist is empty');
      } else {
        console.log('\nWatchlist:');
        for (const token of watchlist) {
          console.log(`  ${token.symbol || 'Unknown'} - ${token.mint}`);
        }
      }
      break;
    }

    case 'sources': {
      const subCmd = args[1]?.toLowerCase();
      const sourceConfig = configStore.getAutoSourceConfig();

      if (!subCmd) {
        // Show status
        console.log('\nAuto-Sources:');
        console.log(`  Enabled: ${sourceConfig.enabled ? 'Yes' : 'No'}`);
        console.log(`  Trending: ${sourceConfig.trending ? 'On' : 'Off'} (limit: ${sourceConfig.trendingLimit})`);
        console.log(`  Whales: ${sourceConfig.whales ? 'On' : 'Off'} (limit: ${sourceConfig.whalesLimit})`);
        console.log(`  Refresh: every ${sourceConfig.refreshIntervalMs / 1000 / 60}m`);
        console.log('\nSource indicators: [W]=watchlist [T]=trending [$]=whales');
        break;
      }

      if (subCmd === 'on') {
        configStore.setAutoSourceEnabled(true);
        await configStore.save();
        console.log('Auto-sources enabled');
        break;
      }

      if (subCmd === 'off') {
        configStore.setAutoSourceEnabled(false);
        await configStore.save();
        console.log('Auto-sources disabled');
        break;
      }

      // Handle "sources trending on|off" or "sources whales on|off"
      const sourceType = subCmd as 'trending' | 'whales';
      const toggle = args[2]?.toLowerCase();

      if ((sourceType === 'trending' || sourceType === 'whales') && (toggle === 'on' || toggle === 'off')) {
        configStore.setSourceEnabled(sourceType, toggle === 'on');
        await configStore.save();
        console.log(`${sourceType} source ${toggle === 'on' ? 'enabled' : 'disabled'}`);
        break;
      }

      console.error('Usage: sources [on|off] | sources <trending|whales> <on|off>');
      break;
    }

    case 'templates': {
      console.log('');
      for (const id of listTemplates()) {
        const template = templates[id];
        console.log(`  ${id}:  ${getTemplateSummary(template)}`);
      }
      console.log('');
      break;
    }

    case 'use': {
      const templateId = args[1];
      if (!templateId) {
        console.error('Usage: use <template>');
        console.error('Available:', listTemplates().join(', '));
        process.exit(1);
      }
      const template = getTemplate(templateId);
      if (!template) {
        console.error(`Template not found: ${templateId}`);
        console.error('Available:', listTemplates().join(', '));
        process.exit(1);
      }
      configStore.addRuleSet(template);
      await configStore.save();
      console.log(`Added template: ${template.name}`);
      break;
    }

    case 'remove': {
      const ruleId = args[1];
      if (!ruleId) {
        console.error('Usage: remove <rule-id>');
        process.exit(1);
      }
      if (configStore.removeRuleSet(ruleId)) {
        await configStore.save();
        console.log(`Removed rule set: ${ruleId}`);
      } else {
        console.log('Rule set not found');
      }
      break;
    }

    case 'rules': {
      const ruleSets = configStore.getRuleSets();
      if (ruleSets.length === 0) {
        console.log('No active rule sets. Use "use <template>" to add one.');
      } else {
        console.log('\nActive Rule Sets:');
        for (const ruleSet of ruleSets) {
          console.log(`\n  ${ruleSet.name} (${ruleSet.id})`);
          console.log(`    Mode: ${ruleSet.mode}`);
          console.log(`    Rules:`);
          for (const rule of ruleSet.rules) {
            const status = rule.enabled ? 'Y' : 'X';
            console.log(`      ${status} ${rule.name} (${rule.ruleType})`);
          }
        }
      }
      break;
    }

    case 'config': {
      const config = configStore.get();
      console.log('\nCurrent Configuration:');
      console.log(`  Watchlist: ${config.watchlist.length} tokens`);
      console.log(`  Rule Sets: ${config.ruleSets.length} active`);
      console.log(`  Auto-Sources: ${config.autoSources.enabled ? 'On' : 'Off'} (T:${config.autoSources.trending ? 'Y' : 'N'} $:${config.autoSources.whales ? 'Y' : 'N'})`);
      console.log(`  Trigger Mode: ${config.trigger.mode}`);
      console.log(`  Trigger Enabled: ${config.trigger.enabled}`);
      console.log(`  Position Size: ${config.trigger.defaultPositionSizeSol} SOL`);
      console.log(`  Poll Interval: ${config.pollIntervalMs}ms`);
      break;
    }

    case 'mode': {
      const mode = args[1] as 'paper' | 'live';
      if (!mode || !['paper', 'live'].includes(mode)) {
        console.error('Usage: mode <paper|live>');
        process.exit(1);
      }
      configStore.setTriggerMode(mode);
      await configStore.save();
      console.log(`Set trigger mode to: ${mode}`);
      break;
    }

    case 'size': {
      const size = parseFloat(args[1]);
      if (isNaN(size) || size <= 0) {
        console.error('Usage: size <sol_amount>');
        process.exit(1);
      }
      configStore.setPositionSize(size);
      await configStore.save();
      console.log(`Set default position size to: ${size} SOL`);
      break;
    }

    case 'filter': {
      const subCmd = args[1]?.toLowerCase();
      const filterConfig = configStore.getMarketFilterConfig();

      if (!subCmd) {
        // Show status
        console.log('\nMarket Filter (SOL Dump Protection):');
        console.log(`  Enabled: ${filterConfig.enabled ? 'Yes' : 'No'}`);
        console.log(`  Timeframe: ${filterConfig.timeframeMinutes}m`);
        console.log(`  Skip Entries: SOL < ${filterConfig.skipEntriesThreshold}%`);
        console.log(`  Exit All: SOL < ${filterConfig.exitAllThreshold}%`);
        console.log(`  Recovery: SOL >= ${filterConfig.recoveryThreshold}%`);
        console.log(`\nState Machine:`);
        console.log(`  NORMAL ──(${filterConfig.skipEntriesThreshold}%)──> CAUTION ──(${filterConfig.exitAllThreshold}%)──> DUMP`);
        console.log(`     ^                                                │`);
        console.log(`     └────────────────(>=${filterConfig.recoveryThreshold}%)────────────────────┘`);
        break;
      }

      if (subCmd === 'on') {
        configStore.setMarketFilterEnabled(true);
        await configStore.save();
        console.log('Market filter enabled');
        break;
      }

      if (subCmd === 'off') {
        configStore.setMarketFilterEnabled(false);
        await configStore.save();
        console.log('Market filter disabled');
        break;
      }

      console.error('Usage: filter [on|off]');
      break;
    }

    case 'analyze': {
      const mint = args[1];
      if (!mint) {
        console.error('Usage: analyze <mint>');
        process.exit(1);
      }

      const ruleSets = configStore.getRuleSets();
      if (ruleSets.length === 0) {
        console.error('No active rule sets. Use "use <template>" to add one.');
        process.exit(1);
      }

      console.log(`\nAnalyzing ${mint}...`);

      const engine = new RuleEngine({ api: localApi });
      for (const ruleSet of ruleSets) {
        engine.addRulesFromConfig(ruleSet.rules);
      }

      const signals = await engine.analyzeToken(mint);
      const result = engine.aggregateSignals(signals);

      console.log(`\nResult: ${result.action.toUpperCase()} (confidence: ${(result.confidence * 100).toFixed(0)}%)`);

      if (signals.length > 0) {
        console.log('\nSignals:');
        for (const signal of signals) {
          const emoji = signal.type === 'buy' ? '+' : signal.type === 'sell' ? '-' : '*';
          console.log(`  ${emoji} ${signal.ruleName}: ${signal.reason}`);
        }
      } else {
        console.log('\nNo signals triggered');
      }

      // Trigger trade if action is not hold
      if (result.action !== 'hold') {
        const trigger = createTrigger(configStore.getTriggerConfig());
        const marketData = await localApi.getMarketData(mint);

        const triggerResult = await trigger.trigger({
          mint,
          symbol: marketData.symbol,
          action: result.action,
          priceSol: marketData.price_sol,
          priceUsd: marketData.price_usd,
          ruleSetId: ruleSets[0].id,
          signals: result.signals,
          confidence: result.confidence,
        });

        if (!triggerResult.triggered) {
          console.log(`\nTrade not triggered: ${triggerResult.reason}`);
        }

        await paperTracker.save();
      }
      break;
    }

    case 'run': {
      // Parse --new-engine flag for gradual cutover
      const useNewEngine = args.includes('--new-engine');

      const watchlist = configStore.getWatchlist();
      const ruleSets = configStore.getRuleSets();

      if (ruleSets.length === 0) {
        console.error('No active rule sets. Use "use <template>" to add one.');
        process.exit(1);
      }

      const config = configStore.get();
      const trigger = createTrigger(config.trigger);
      const autoSources = createAutoSourceManager(localApi, config.autoSources);

      // Set up market filter with config
      marketFilter.updateConfig(config.marketFilter);
      marketFilter.setApi(localApi);

      // Initial refresh of auto-sources
      if (config.autoSources.enabled) {
        console.log('Fetching auto-sources (trending, whales)...');
        await autoSources.refresh();
      }

      // Helper to get source label for output
      const sourceLabel = (source: TokenSource): string => {
        switch (source) {
          case 'watchlist': return 'W';
          case 'trending': return 'T';
          case 'whales': return '$';
          default: return '?';
        }
      };

      // Combine all token sources: watchlist + auto-sources + open positions
      const getAllTokens = () => {
        const tokens = new Map<string, { mint: string; symbol?: string; source: TokenSource }>();

        // Manual watchlist (highest priority)
        for (const t of watchlist) {
          tokens.set(t.mint, { mint: t.mint, symbol: t.symbol, source: 'watchlist' });
        }

        // Auto-sources (if enabled)
        if (config.autoSources.enabled) {
          for (const t of autoSources.getSourcedTokens()) {
            if (!tokens.has(t.mint)) {
              tokens.set(t.mint, { mint: t.mint, symbol: t.symbol, source: t.source });
            }
          }
        }

        // Open positions (always include)
        for (const trade of paperTracker.getOpenTrades()) {
          if (!tokens.has(trade.mint)) {
            // Determine source from auto-sources if available
            const autoSource = autoSources.getSourceForMint(trade.mint);
            tokens.set(trade.mint, {
              mint: trade.mint,
              symbol: trade.symbol,
              source: autoSource || 'watchlist',
            });
          }
        }

        return Array.from(tokens.values());
      };

      const allTokens = getAllTokens();
      const autoSourceCounts = autoSources.getCounts();

      if (allTokens.length === 0) {
        console.error('Nothing to watch. Add tokens with "watch <mint>", enable auto-sources, or have open trades.');
        process.exit(1);
      }

      const openCount = paperTracker.getOpenTrades().length;
      const mfStatus = config.marketFilter.enabled ? 'On' : 'Off';

      // Start WebSocket server for frontend
      wsServer.start(8765);

      // Helper to get current config for broadcasting
      const getCurrentConfig = (): ConfigData => ({
        autoSourcesEnabled: configStore.getAutoSourceConfig().enabled,
        trendingEnabled: configStore.getAutoSourceConfig().trending,
        whalesEnabled: configStore.getAutoSourceConfig().whales,
        marketFilterEnabled: configStore.getMarketFilterConfig().enabled,
        mode: configStore.getTriggerConfig().mode,
        positionSizeSol: configStore.getTriggerConfig().defaultPositionSizeSol,
        pollIntervalMs: configStore.get().pollIntervalMs,
      });

      // Helper to get strategies data for broadcasting
      const getStrategiesData = (): StrategiesData => {
        const activeRuleSets = configStore.getRuleSets();
        const activeIds = new Set(activeRuleSets.map(r => r.id));

        const available: StrategyInfo[] = listTemplates().map(id => {
          const t = templates[id];
          return {
            id: t.id,
            name: t.name,
            description: t.description,
            mode: t.mode,
            ruleCount: t.rules.length,
            summary: getTemplateSummary(t),
          };
        });

        return {
          available,
          active: Array.from(activeIds),
        };
      };

      // Handle commands from frontend
      wsServer.onCommand(async (cmd: AutopilotCommand) => {
        switch (cmd.command) {
          case 'toggle_sources':
            configStore.setAutoSourceEnabled(cmd.enabled);
            await configStore.save();
            console.log(`[WS] Auto-sources ${cmd.enabled ? 'enabled' : 'disabled'}`);
            break;
          case 'toggle_trending':
            configStore.setSourceEnabled('trending', cmd.enabled);
            await configStore.save();
            console.log(`[WS] Trending source ${cmd.enabled ? 'enabled' : 'disabled'}`);
            break;
          case 'toggle_whales':
            configStore.setSourceEnabled('whales', cmd.enabled);
            await configStore.save();
            console.log(`[WS] Whales source ${cmd.enabled ? 'enabled' : 'disabled'}`);
            break;
          case 'toggle_filter':
            configStore.setMarketFilterEnabled(cmd.enabled);
            await configStore.save();
            console.log(`[WS] Market filter ${cmd.enabled ? 'enabled' : 'disabled'}`);
            marketFilter.updateConfig(configStore.getMarketFilterConfig());
            break;
          case 'set_mode':
            configStore.setTriggerMode(cmd.mode);
            await configStore.save();
            console.log(`[WS] Mode set to ${cmd.mode}`);
            break;
          case 'set_position_size':
            configStore.setPositionSize(cmd.sizeSol);
            await configStore.save();
            console.log(`[WS] Position size set to ${cmd.sizeSol} SOL`);
            break;
          case 'refresh_sources':
            console.log('[WS] Refreshing auto-sources...');
            await autoSources.refresh();
            break;
          case 'get_config':
            // Just broadcast current config
            break;
          case 'get_strategies':
            // Just broadcast strategies
            break;
          case 'toggle_strategy': {
            const strategyId = cmd.strategyId;
            const enable = cmd.enabled;
            if (enable) {
              // Add strategy from templates
              const template = getTemplate(strategyId);
              if (template) {
                configStore.addRuleSet(template);
                await configStore.save();
                // Reload rules in engine
                engine.clearRules();
                for (const ruleSet of configStore.getRuleSets()) {
                  engine.addRulesFromConfig(ruleSet.rules);
                }
                console.log(`[WS] Strategy enabled: ${template.name}`);
              }
            } else {
              // Remove strategy
              if (configStore.removeRuleSet(strategyId)) {
                await configStore.save();
                // Reload rules in engine
                engine.clearRules();
                for (const ruleSet of configStore.getRuleSets()) {
                  engine.addRulesFromConfig(ruleSet.rules);
                }
                console.log(`[WS] Strategy disabled: ${strategyId}`);
              }
            }
            break;
          }
          case 'close_position': {
            const mint = cmd.mint;
            const openTrade = paperTracker.getOpenTradeForMint(mint);
            if (openTrade) {
              try {
                const marketData = await localApi.getMarketData(mint);
                await trigger.closePosition(mint, marketData.price_sol, marketData.price_usd);
                await paperTracker.save();
                console.log(`[WS] Closed position: ${openTrade.symbol}`);
              } catch (err) {
                console.error(`[WS] Failed to close position ${mint}:`, err);
              }
            } else {
              console.log(`[WS] No open position for mint: ${mint}`);
            }
            break;
          }
          case 'close_all_positions': {
            const openTrades = paperTracker.getOpenTrades();
            if (openTrades.length === 0) {
              console.log('[WS] No open positions to close');
            } else {
              console.log(`[WS] Closing all ${openTrades.length} positions...`);
              for (const trade of openTrades) {
                try {
                  const marketData = await localApi.getMarketData(trade.mint);
                  await trigger.closePosition(trade.mint, marketData.price_sol, marketData.price_usd);
                  console.log(`[WS] Closed: ${trade.symbol}`);
                } catch (err) {
                  console.error(`[WS] Failed to close ${trade.symbol}:`, err);
                }
              }
              await paperTracker.save();
              console.log('[WS] All positions closed');
            }
            break;
          }
        }
        // Always broadcast updated config and strategies after any command
        wsServer.broadcastConfig(getCurrentConfig());
        wsServer.broadcastStrategies(getStrategiesData());
      });

      // Send initial state to newly connected clients
      wsServer.onConnect(() => {
        wsServer.broadcastConfig(getCurrentConfig());
        const strategiesData = getStrategiesData();
        console.log(`[WS] Sending initial state: ${strategiesData.available.length} strategies available, ${strategiesData.active.length} active`);
        wsServer.broadcastStrategies(strategiesData);
      });

      console.log('Starting analysis loop... (Ctrl+C to stop)');
      console.log(`  Watchlist: ${watchlist.length} | Trending: ${autoSourceCounts.trending} | Whales: ${autoSourceCounts.whales}`);
      console.log(`  Open trades: ${openCount} | Rules: ${ruleSets.length} sets | Mode: ${config.trigger.mode}`);
      console.log(`  Market Filter: ${mfStatus} (skip@${config.marketFilter.skipEntriesThreshold}% exit@${config.marketFilter.exitAllThreshold}%)`);
      console.log(`  Scan interval: ${config.pollIntervalMs}ms | Source refresh: ${config.autoSources.refreshIntervalMs / 1000}s`);
      console.log(`  WebSocket: ws://localhost:8765\n`);

      const engine = new RuleEngine({ api: localApi });
      for (const ruleSet of ruleSets) {
        engine.addRulesFromConfig(ruleSet.rules);
      }

      // Signal pipeline: routes data feeds through SignalProcessor
      const pipeline = createSignalPipeline(engine, {
        marketDataProvider: () => wsServer.getAllMarketData(),
      });

      // Register signal callback to broadcast via WebSocket
      pipeline.onSignal((signal) => {
        wsServer.broadcastSignal({
          timestamp: Date.now(),
          mint: signal.mint || '',
          symbol: signal.ruleName || 'Unknown',
          signalType: 'rule_signal',
          action: signal.type === 'buy' ? 'buy' : signal.type === 'sell' ? 'sell' : 'close',
          reason: signal.reason,
        });
      });

      // Wire data feed handling to signal pipeline and auto-sources
      wsServer.onDataFeed((message) => {
        if (message.type === 'trending_feed') {
          autoSources.setTrendingFromFeed(message.tokens);
          console.log(`[AutoSources] Received ${message.tokens.length} trending tokens via feed (${message.resolution})`);
        } else if (message.type === 'whale_feed') {
          autoSources.setWhalesFromFeed(message.tokens);
          console.log(`[AutoSources] Received ${message.tokens.length} whale tokens via feed`);
        }
        pipeline.handleDataFeed(message);
      });

      console.log('[Signal] Pipeline initialized');

      // Engine mode indicator
      if (useNewEngine) {
        console.log('[Engine] NEW ENGINE ONLY - signal pipeline handles all analysis');
      } else {
        console.log('[Engine] PARALLEL MODE - both old and new engines running');
      }

      let scanCount = 0;
      const runLoop = async () => {
        scanCount++;
        const time = new Date().toLocaleTimeString('en-US', { hour12: false });

        // Refresh auto-sources if needed (every 15m by default)
        await autoSources.refreshIfNeeded();

        // Get fresh token list
        const tokens = getAllTokens();
        const openTrades = paperTracker.getOpenTrades();
        const openMints = new Set(openTrades.map(t => t.mint));

        // Batch fetch all market data upfront (including SOL for market filter)
        const allMints = [...tokens.map(t => t.mint)];
        if (!allMints.includes(SOL_MINT)) {
          allMints.push(SOL_MINT);
        }
        let marketDataCache = await localApi.getMarketDataBatch(allMints);

        // Workaround: local-api batch returns empty if ANY mint is invalid
        // Fall back to individual fetches for watchlist + open trades
        if (marketDataCache.size === 0) {
          marketDataCache = new Map();
          const priorityMints = new Set([
            ...configStore.getWatchlist().map(t => t.mint),
            ...openTrades.map(t => t.mint),
          ]);
          for (const mint of priorityMints) {
            try {
              const data = await localApi.getMarketData(mint);
              if (data) marketDataCache.set(mint, data);
            } catch {
              // Token not found in local database
            }
          }
        }

        // Check market filter (SOL dump protection)
        // Try direct SOL data first, fallback to deriving from token prices
        const solData = marketDataCache.get(SOL_MINT);
        const marketFilterResult = marketFilter.check(solData, undefined, marketDataCache);

        // Fetch 1m candles for open positions (needed for Williams TSL)
        // Only fetch for positions we have open - this enables trailing stop
        const candleDataMap = new Map<string, import('./api/types.js').OHLCV[]>();
        for (const trade of openTrades) {
          try {
            // Fetch last 50 1m candles (enough for 3/3 fractal detection)
            const candles = await localApi.getOHLCV(trade.mint, '1m', { countback: 50 });
            if (candles.length > 0) {
              candleDataMap.set(trade.mint, candles);
            }
          } catch {
            // OHLCV not available for this token - TSL won't work but TP/SL will
          }
        }

        // Check magic exits (TP at resistance, SL at support break, TSL at fractal)
        // Magic exits still run even in CAUTION mode (structure-based exits are always valid)
        const magicExitResults = await magicExits.executeExits(marketDataCache, true, candleDataMap);

        // Handle market dump - exit all positions
        let marketDumpExits: typeof magicExitResults = [];
        if (marketFilterResult.exitAll) {
          marketDumpExits = await marketFilter.executeExitAll(marketDataCache, true);
        }

        // Magic buy - auto-enter at support levels (only if market filter allows entries)
        // Uses same OHLCV data as TSL for SFP detection
        const magicBuyResults = !marketFilterResult.blockEntries
          ? await magicBuy.executeEntries(marketDataCache, candleDataMap, true)
          : { entries: [], skipped: [] };

        const scanResults: string[] = [];
        const tradeResults: string[] = [];
        const magicResults: string[] = [];
        const magicEntryResults: string[] = [];
        const dumpExitResults: string[] = [];

        // Record market dump exits
        for (const closed of marketDumpExits) {
          const pnlSign = (closed.pnlPercent ?? 0) >= 0 ? '+' : '';
          const color = (closed.pnlPercent ?? 0) >= 0 ? '\x1b[32m' : '\x1b[31m';
          const reset = '\x1b[0m';
          dumpExitResults.push(`${closed.symbol}:${color}${pnlSign}${closed.pnlPercent?.toFixed(1)}%${reset}`);
        }

        // Record magic exits
        for (const closed of magicExitResults) {
          const pnlSign = (closed.pnlPercent ?? 0) >= 0 ? '+' : '';
          const color = (closed.pnlPercent ?? 0) >= 0 ? '\x1b[32m' : '\x1b[31m';
          const reset = '\x1b[0m';
          magicResults.push(`${closed.symbol}:${color}${pnlSign}${closed.pnlPercent?.toFixed(1)}%${reset}`);
        }

        // Record magic buy entries
        for (const { trade, entry } of magicBuyResults.entries) {
          const entryLabel = entry.entryType?.toUpperCase() || 'BUY';
          const color = '\x1b[36m'; // Cyan for new entries
          const reset = '\x1b[0m';
          magicEntryResults.push(`${color}${trade.symbol}[${entryLabel}]${reset}`);
        }

        // Process all tokens (fast path - no additional API calls)
        // PARALLEL MODE: Run old polling analysis alongside signal pipeline
        // NEW ENGINE MODE: Skip this loop - signal pipeline handles analysis reactively
        if (!useNewEngine) {
        for (const token of tokens) {
          const isOpenTrade = openMints.has(token.mint);

          // Get cached market data first
          const marketData = marketDataCache.get(token.mint);
          if (!marketData) continue; // Skip tokens without data

          const sym = token.symbol || marketData.symbol || token.mint.slice(0, 6);
          const src = sourceLabel(token.source);

          try {
            // Use fast path - analyze with pre-fetched market data (no API calls)
            const signals = engine.analyzeWithMarketData(marketData);
            const result = engine.aggregateSignals(signals);

            // Calculate metrics for last_analysis broadcast
            const price5mAgo = marketData.earliest_price_sol_5m || marketData.price_sol;
            const price1hAgo = marketData.earliest_price_sol_1h || marketData.price_sol;
            const priceChange5m = price5mAgo > 0 ? ((marketData.price_sol - price5mAgo) / price5mAgo) * 100 : null;
            const priceChange1h = price1hAgo > 0 ? ((marketData.price_sol - price1hAgo) / price1hAgo) * 100 : null;
            const buyVol = marketData.buy_volume_sol_5m || 0;
            const sellVol = marketData.sell_volume_sol_5m || 0;
            const totalVol = buyVol + sellVol;
            const buySellRatio = sellVol > 0 ? buyVol / sellVol : (buyVol > 0 ? 999 : 1);

            // Broadcast last analysis result
            // Note: signals array contains only triggered signals, result.signals is the aggregated list
            const totalRules = engine.getRules().length;
            wsServer.broadcastLastAnalysis({
              mint: token.mint,
              symbol: sym,
              timestamp: Date.now(),
              priceChange5m,
              priceChange1h,
              volumeRatio: null, // Would need baseline comparison
              buyersCount: marketData.buyers_5m || null,
              sellersCount: marketData.sellers_5m || null,
              buySellRatio: totalVol > 0 ? buySellRatio : null,
              rulesChecked: totalRules,
              rulesMatched: signals.length,
              outcome: result.action === 'hold' ? 'no_signal' : result.action === 'buy' ? 'buy_signal' : 'sell_signal',
              reason: result.action === 'hold'
                ? `${signals.length}/${totalRules} rules matched`
                : `${result.action.toUpperCase()} - ${result.signals.map(s => s.ruleName).join(', ')}`,
            });

            // If this is an open trade, show P&L
            if (isOpenTrade) {
              const trade = openTrades.find(t => t.mint === token.mint)!;
              const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
              const sign = pnl.pnlPercent >= 0 ? '+' : '';
              const size = trade.positionSizeSol.toFixed(2);
              const color = pnl.pnlPercent >= 0 ? '\x1b[32m' : '\x1b[31m';
              const reset = '\x1b[0m';
              tradeResults.push(`[${src}]${sym} (${size}) ${color}${sign}${pnl.pnlPercent.toFixed(1)}%${reset}`);

              // Check for exit signals
              if (result.action !== 'hold') {
                const triggerResult = await trigger.trigger({
                  mint: token.mint,
                  symbol: trade.symbol,
                  action: result.action,
                  priceSol: marketData.price_sol,
                  priceUsd: marketData.price_usd,
                  ruleSetId: ruleSets[0].id,
                  signals: result.signals,
                  confidence: result.confidence,
                  quiet: true,
                });
                if (triggerResult.triggered) {
                  tradeResults[tradeResults.length - 1] += ' EXIT';
                }
                await paperTracker.save();
              }
            } else {
              // Scan result (not an open trade)
              if (result.action !== 'hold') {
                // Skip new entries if market filter is blocking
                if (marketFilterResult.blockEntries && result.action === 'buy') {
                  // Don't open new long positions during market stress
                  continue;
                }

                const conf = (result.confidence * 100).toFixed(0);
                const color = result.action === 'buy' ? '\x1b[32m' : '\x1b[31m';
                const reset = '\x1b[0m';

                const triggerResult = await trigger.trigger({
                  mint: token.mint,
                  symbol: marketData.symbol || token.symbol || 'UNKNOWN',
                  action: result.action,
                  priceSol: marketData.price_sol,
                  priceUsd: marketData.price_usd,
                  ruleSetId: ruleSets[0].id,
                  signals: result.signals,
                  confidence: result.confidence,
                  quiet: true,
                });

                // Only show signals that actually triggered a trade
                if (triggerResult.triggered) {
                  scanResults.push(`[${src}]${sym}:${color}${result.action.toUpperCase()}(${conf}%)${reset}`);
                }
                await paperTracker.save();
              }
            }
          } catch {
            if (isOpenTrade) {
              tradeResults.push(`[${src}]${sym}:ERR`);
            } else {
              scanResults.push(`[${src}]${sym}:ERR`);
            }
          }
        }
        } // end if (!useNewEngine) - old polling analysis

        // Output - compact single line
        let line = `[${time}] #${scanCount}`;

        // Market filter status (always show if not NORMAL)
        if (marketFilterResult.state !== 'NORMAL') {
          const mfColor = marketFilterResult.state === 'DUMP' ? '\x1b[31m' : '\x1b[33m';
          const reset = '\x1b[0m';
          const changeStr = marketFilterResult.priceChangePercent.toFixed(1);
          line += `  |  ${mfColor}SOL ${changeStr}% [${marketFilterResult.state}]${reset}`;
        }

        // Market dump exits
        if (dumpExitResults.length > 0) {
          line += `  |  DumpExit: ${dumpExitResults.join(' ')}`;
        }

        // Magic exits
        if (magicResults.length > 0) {
          line += `  |  MagicExit: ${magicResults.join(' ')}`;
        }

        // Magic buy entries
        if (magicEntryResults.length > 0) {
          line += `  |  MagicBuy: ${magicEntryResults.join(' ')}`;
        }

        // New trades (from rule signals)
        if (scanResults.length > 0) {
          line += `  |  Signal: ${scanResults.join(' ')}`;
        }

        // Open positions
        if (tradeResults.length > 0) {
          line += `  |  Open: ${tradeResults.join(' ')}`;
        }

        // No activity indicator
        if (scanResults.length === 0 && tradeResults.length === 0 && magicResults.length === 0 && magicEntryResults.length === 0 && dumpExitResults.length === 0) {
          if (marketFilterResult.state === 'NORMAL') {
            line += `  |  (${tokens.length} tokens)  |  No signals`;
          }
        }

        console.log(line);

        // === WebSocket Broadcasts ===

        // Broadcast scan tick
        wsServer.broadcastScanTick({
          timestamp: Date.now(),
          scanNumber: scanCount,
          tokenCount: tokens.length,
          openPositions: openTrades.length,
        });

        // Broadcast token list grouped by source
        const tokenListData: TokenListData = {
          watchlist: [],
          trending: [],
          whales: [],
        };
        for (const token of tokens) {
          const marketData = marketDataCache.get(token.mint);
          const watchedToken: WatchedToken = {
            mint: token.mint,
            symbol: token.symbol || marketData?.symbol || token.mint.slice(0, 6),
            source: token.source,
            priceSol: marketData?.price_sol,
            priceUsd: marketData?.price_usd,
            change1h: marketData?.earliest_price_sol_1h ? ((marketData.price_sol - marketData.earliest_price_sol_1h) / marketData.earliest_price_sol_1h) * 100 : undefined,
            change24h: marketData?.earliest_price_sol_24h ? ((marketData.price_sol - marketData.earliest_price_sol_24h) / marketData.earliest_price_sol_24h) * 100 : undefined,
            volume24h: marketData?.volume_24h_sol,
            mcap: marketData?.market_cap_usd,
            hasPosition: openMints.has(token.mint),
          };
          if (token.source === 'watchlist') {
            tokenListData.watchlist.push(watchedToken);
          } else if (token.source === 'trending') {
            tokenListData.trending.push(watchedToken);
          } else if (token.source === 'whales') {
            tokenListData.whales.push(watchedToken);
          }
        }
        wsServer.broadcastTokenList(tokenListData);

        // Broadcast market status
        wsServer.broadcastMarketStatus({
          state: marketFilterResult.state as 'NORMAL' | 'CAUTION' | 'DUMP',
          solPriceChangePercent: marketFilterResult.priceChangePercent,
          blockEntries: marketFilterResult.blockEntries,
          exitAll: marketFilterResult.exitAll,
        });

        // Broadcast position entries (frontend fetches prices via NATS)
        const positionData: PositionData[] = openTrades.map(trade => ({
          mint: trade.mint,
          symbol: trade.symbol,
          action: trade.action,
          entryPriceSol: trade.entryPriceSol,
          positionSizeSol: trade.positionSizeSol,
          entryTime: trade.timestamp,
        }));
        if (positionData.length > 0) {
          console.log(`[WS] Broadcasting ${positionData.length} positions: ${positionData.map(p => p.symbol).join(', ')}`);
        }
        wsServer.broadcastPositions(positionData);

        // Broadcast signals for magic exits
        for (const closed of magicExitResults) {
          wsServer.broadcastSignal({
            timestamp: Date.now(),
            mint: closed.mint,
            symbol: closed.symbol,
            signalType: 'magic_exit',
            action: 'close',
            reason: closed.reason || 'Magic exit triggered',
            pnlPercent: closed.pnlPercent,
          });
        }

        // Broadcast signals for dump exits
        for (const closed of marketDumpExits) {
          wsServer.broadcastSignal({
            timestamp: Date.now(),
            mint: closed.mint,
            symbol: closed.symbol,
            signalType: 'dump_exit',
            action: 'close',
            reason: 'Market dump protection',
            pnlPercent: closed.pnlPercent,
          });
        }

        // Broadcast signals for magic buy entries
        for (const { trade, entry } of magicBuyResults.entries) {
          wsServer.broadcastSignal({
            timestamp: Date.now(),
            mint: trade.mint,
            symbol: trade.symbol,
            signalType: 'magic_buy',
            action: 'buy',
            reason: entry.reason,
            entryType: entry.entryType || undefined,
          });
        }

        // Broadcast updated stats
        const stats = paperTracker.getStats();
        wsServer.broadcastStats({
          totalTrades: stats.totalTrades,
          openTrades: stats.openTrades,
          closedTrades: stats.closedTrades,
          wins: stats.wins,
          losses: stats.losses,
          winRate: stats.winRate,
          totalPnlSol: stats.totalPnlSol,
          totalPnlUsd: stats.totalPnlUsd,
          avgPnlPercent: stats.avgPnlPercent,
        });
      };

      // Run immediately, then on interval
      await runLoop();
      setInterval(runLoop, config.pollIntervalMs);
      break;
    }

    case 'status': {
      const openTrades = paperTracker.getOpenTrades();
      const stats = paperTracker.getStats();
      const ruleSets = configStore.getRuleSets();
      const watchlist = configStore.getWatchlist();

      console.log('\n=== PORTFOLIO STATUS ===\n');

      // Open positions with live P&L
      if (openTrades.length === 0) {
        console.log('Open Positions: none\n');
      } else {
        console.log('Open Positions:');
        let totalUnrealizedSol = 0;
        let totalUnrealizedUsd = 0;
        let totalExposure = 0;

        for (const trade of openTrades) {
          try {
            const marketData = await localApi.getMarketData(trade.mint);
            const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
            const sign = pnl.pnlPercent >= 0 ? '+' : '';
            totalUnrealizedSol += pnl.pnlSol;
            totalUnrealizedUsd += pnl.pnlUsd;
            totalExposure += trade.positionSizeSol;

            console.log(`  ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${pnl.pnlPercent.toFixed(2)}%  (${sign}${pnl.pnlSol.toFixed(4)} SOL)`);
            console.log(`    Entry: ${trade.entryPriceSol} -> Now: ${marketData.price_sol} SOL`);
          } catch {
            console.log(`  ${trade.action.toUpperCase()} ${trade.symbol}  (price fetch failed)`);
          }
        }

        const unrealizedSign = totalUnrealizedSol >= 0 ? '+' : '';
        console.log(`\n  Exposure: ${totalExposure.toFixed(4)} SOL`);
        console.log(`  Unrealized: ${unrealizedSign}${totalUnrealizedSol.toFixed(4)} SOL ($${totalUnrealizedUsd.toFixed(2)})\n`);
      }

      // Realized P&L
      console.log('Realized P&L:');
      const realizedSign = stats.totalPnlSol >= 0 ? '+' : '';
      console.log(`  ${stats.closedTrades} trades | ${stats.wins}W/${stats.losses}L | ${(stats.winRate * 100).toFixed(0)}% win`);
      console.log(`  Total: ${realizedSign}${stats.totalPnlSol.toFixed(4)} SOL ($${stats.totalPnlUsd.toFixed(2)})\n`);

      // Active config
      console.log('Config:');
      console.log(`  Watching: ${watchlist.length} tokens | Rules: ${ruleSets.length} sets`);
      console.log(`  Mode: ${configStore.getTriggerConfig().mode}\n`);

      break;
    }

    case 'trades': {
      const trades = paperTracker.getAllTrades();
      if (trades.length === 0) {
        console.log('No trades recorded');
      } else {
        console.log('\nPaper Trades:');
        for (const trade of trades) {
          if (trade.status === 'open') {
            try {
              const marketData = await localApi.getMarketData(trade.mint);
              const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
              const sign = pnl.pnlPercent >= 0 ? '+' : '';
              console.log(`  [OPEN] ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${pnl.pnlPercent.toFixed(2)}%`);
              console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
            } catch {
              console.log(`  [OPEN] ${trade.action.toUpperCase()} ${trade.symbol}`);
              console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
            }
          } else {
            const sign = (trade.pnlPercent ?? 0) >= 0 ? '+' : '';
            console.log(`  [CLOSED] ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${trade.pnlPercent?.toFixed(2)}%`);
            console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
          }
        }
      }
      break;
    }

    case 'stats': {
      const stats = paperTracker.getStats();
      console.log('\nTrading Statistics:');
      console.log(`  Total Trades: ${stats.totalTrades}`);
      console.log(`  Open: ${stats.openTrades} | Closed: ${stats.closedTrades}`);
      console.log(`  Wins: ${stats.wins} | Losses: ${stats.losses}`);
      console.log(`  Win Rate: ${(stats.winRate * 100).toFixed(1)}%`);
      console.log(`  Total P&L: ${stats.totalPnlSol.toFixed(4)} SOL ($${stats.totalPnlUsd.toFixed(2)})`);
      console.log(`  Avg P&L: ${stats.avgPnlPercent.toFixed(2)}%`);
      if (stats.bestTrade) {
        console.log(`  Best: ${stats.bestTrade.symbol} +${stats.bestTrade.pnlPercent?.toFixed(2)}%`);
      }
      if (stats.worstTrade) {
        console.log(`  Worst: ${stats.worstTrade.symbol} ${stats.worstTrade.pnlPercent?.toFixed(2)}%`);
      }
      break;
    }

    case 'close': {
      const mint = args[1];
      if (!mint) {
        console.error('Usage: close <mint>');
        process.exit(1);
      }

      const openTrade = paperTracker.getOpenTradeForMint(mint);
      if (!openTrade) {
        console.log('No open position for this mint');
        break;
      }

      const marketData = await localApi.getMarketData(mint);
      const trigger = createTrigger(configStore.getTriggerConfig());
      await trigger.closePosition(mint, marketData.price_sol, marketData.price_usd);
      await paperTracker.save();
      break;
    }

    case 'reset': {
      paperTracker.clearAll();
      await paperTracker.save();
      console.log('All trading data cleared');
      break;
    }

    case 'help':
    default:
      console.log(HELP);
  }
}

main().catch(console.error);
