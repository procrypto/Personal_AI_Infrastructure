/* eslint-disable lingui/no-unlocalized-strings */
import { useMemo, useState, useCallback } from "react";
import {
  createColumnHelper,
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  flexRender,
  type SortingState,
  type Row,
} from "@tanstack/react-table";
import { useNavigate } from "@tanstack/react-router";
import { cn } from "@/lib/utils";
import { TokenImage } from "@/components/token-image";
import { getBonkbotImageUrl } from "@/utils/asset-mappers";
import { FormattedNumber } from "@/components/formatted-number/formatted-number";
import { WatchlistToggle } from "@/components/watchlist-toggle/watchlist-toggle";
import { TableSort } from "@/components/table/table-sort";
import type {
  AutopilotTokenWithPrices,
  SignalStrength,
} from "@/hooks/useAutopilot";
import { HideTokenButton } from "./hide-token-button";

// Map confluence count to background opacity (using brand palette)
// Subtle tiers - one level down for softer appearance
function getSignalOpacity(
  confluenceCount: number,
  isFlashing: boolean
): number {
  if (isFlashing) return 0.5;
  if (confluenceCount >= 6) return 0.4;
  if (confluenceCount === 5) return 0.35;
  if (confluenceCount === 4) return 0.3;
  if (confluenceCount === 3) return 0.2;
  if (confluenceCount === 2) return 0.1;
  if (confluenceCount === 1) return 0.05;
  return 0;
}

// Get signal background style based on confluence
function getSignalStyle(
  signalStrength?: SignalStrength
): React.CSSProperties | undefined {
  if (!signalStrength || signalStrength.type === "none") {
    return undefined;
  }

  const opacity = getSignalOpacity(signalStrength.confluenceCount, false);

  if (signalStrength.type === "buy") {
    return { backgroundColor: `rgba(180, 229, 89, ${opacity})` };
  } else {
    return { backgroundColor: `rgba(239, 68, 68, ${opacity})` };
  }
}

// Get sort priority for confluence-based default sorting
// Green (buy) signals first (sorted by count desc), then red (sell), then none
function getConfluenceSortPriority(signal?: SignalStrength): number {
  if (!signal || signal.type === "none") return 1000; // No signal = lowest priority
  if (signal.type === "buy") return -signal.confluenceCount; // Negative = higher priority, higher count = even higher
  return 100 - signal.confluenceCount; // Sell signals after buy, higher count = higher within sell
}

const columnHelper = createColumnHelper<AutopilotTokenWithPrices>();

type ScreenerTableProps = {
  tokens: AutopilotTokenWithPrices[];
  columnType: "watchlist" | "trending" | "whales";
  signalStrengthMap: Map<string, SignalStrength>;
  title: string;
  icon: React.ElementType;
};

export const ScreenerTable = ({
  tokens,
  columnType,
  signalStrengthMap,
  title,
  icon: Icon,
}: ScreenerTableProps) => {
  const navigate = useNavigate();
  const [sorting, setSorting] = useState<SortingState>([]);

  // Navigate to trading page on row click
  const handleRowClick = useCallback(
    (row: Row<AutopilotTokenWithPrices>) => {
      navigate({ to: "/trading/$mint", params: { mint: row.original.mint } });
    },
    [navigate]
  );

  // Default sort: green confluence high → red confluence → rest
  // Applied when no user sort is active
  const sortedTokens = useMemo(() => {
    if (sorting.length > 0) {
      // User has applied sorting, let TanStack handle it
      return tokens;
    }

    // Default confluence-based sort
    return [...tokens].sort((a, b) => {
      const sigA = signalStrengthMap.get(a.mint);
      const sigB = signalStrengthMap.get(b.mint);

      const priorityA = getConfluenceSortPriority(sigA);
      const priorityB = getConfluenceSortPriority(sigB);

      return priorityA - priorityB;
    });
  }, [tokens, signalStrengthMap, sorting.length]);

  // Define columns - Action first, then Signal, then data columns
  const columns = useMemo(
    () => [
      // Action column (first - star/hide on left)
      columnHelper.display({
        id: "action",
        header: "",
        cell: ({ row }) => {
          const token = row.original;

          if (columnType === "watchlist") {
            return (
              <WatchlistToggle
                mint={token.mint}
                ticker={token.symbol}
                disableTooltip
              />
            );
          }

          return (
            <HideTokenButton
              mint={token.mint}
              symbol={token.symbol}
            />
          );
        },
        size: 24,
        enableSorting: false,
      }),
      // Signal column - shows confluence arrow + count
      columnHelper.display({
        id: "signal",
        header: "",
        cell: ({ row }) => {
          const signal = signalStrengthMap.get(row.original.mint);

          if (!signal || signal.type === "none") {
            return null;
          }

          return (
            <span
              className={cn(
                "flex items-center gap-0.5 text-[10px] font-semibold",
                signal.type === "buy" ? "text-text-success" : "text-text-error"
              )}
            >
              {signal.type === "buy" ? "▲" : "▼"}
              {signal.confluenceCount}
            </span>
          );
        },
        size: 28,
        enableSorting: false,
      }),
      // Token column
      columnHelper.accessor(row => row.symbol, {
        id: "symbol",
        header: "Token",
        cell: ({ row }) => {
          const token = row.original;
          const { imgSrc, isCrossOrigin } = getBonkbotImageUrl(token.mint);

          return (
            <div className="flex items-center gap-1.5 overflow-hidden">
              <TokenImage
                symbol={token.symbol}
                imgSrc={imgSrc}
                isCrossOrigin={isCrossOrigin}
                alt=""
                className="size-3.5 min-w-3.5 rounded"
              />
              <span className="text-text-primary truncate text-xs font-medium">
                ${token.symbol}
              </span>
            </div>
          );
        },
        size: 90,
        enableSorting: true,
      }),
      // MCap column
      columnHelper.accessor(row => row.marketCapUsd ?? 0, {
        id: "mcap",
        header: "MCap",
        cell: ({ getValue }) => (
          <FormattedNumber
            preset="usd"
            value={getValue()}
          />
        ),
        size: 65,
        enableSorting: true,
      }),
      // 1h % column
      columnHelper.accessor(row => row.change1h ?? 0, {
        id: "change1h",
        header: "1h %",
        cell: ({ getValue }) => (
          <FormattedNumber
            value={getValue()}
            showPositiveSign
            preset="percentage"
            showColor
          />
        ),
        size: 55,
        enableSorting: true,
      }),
    ],
    [columnType, signalStrengthMap]
  );

  const table = useReactTable({
    data: sortedTokens,
    columns,
    state: { sorting },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getRowId: row => row.mint,
  });

  return (
    <div className="flex min-h-0 flex-1 flex-col">
      {/* Column header - Discovery style: larger, light colored */}
      <div className="text-text-secondary mb-2 flex items-center gap-2 text-sm font-medium">
        <Icon className="size-4" />
        {title}
        <span className="text-text-tertiary text-xs">({tokens.length})</span>
      </div>

      {tokens.length === 0 ? (
        <div className="text-text-tertiary border-border-primary/30 rounded border border-dashed p-2 text-center text-[10px]">
          No tokens
        </div>
      ) : (
        <div className="min-h-0 flex-1 overflow-auto">
          <table className="w-full">
            {/* Table header */}
            <thead className="sticky top-0 z-10">
              {table.getHeaderGroups().map(headerGroup => (
                <tr
                  key={headerGroup.id}
                  className="bg-bg-secondary border-border-primary/30 border-b"
                >
                  {headerGroup.headers.map(header => {
                    const canSort = header.column.getCanSort();
                    const sortDirection = header.column.getIsSorted();

                    return (
                      <th
                        key={header.id}
                        className={cn(
                          "text-text-tertiary px-1 py-1 text-left text-[9px] font-medium",
                          canSort && "cursor-pointer select-none"
                        )}
                        style={{ width: header.getSize() }}
                        onClick={
                          canSort
                            ? header.column.getToggleSortingHandler()
                            : undefined
                        }
                      >
                        <div className="flex items-center gap-0.5">
                          {flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                          {canSort && (
                            <TableSort
                              sortDirection={sortDirection}
                              className="size-2.5"
                            />
                          )}
                        </div>
                      </th>
                    );
                  })}
                </tr>
              ))}
            </thead>

            {/* Table body */}
            <tbody>
              {table.getRowModel().rows.map((row, index) => {
                const signalStrength = signalStrengthMap.get(row.original.mint);
                const hasSignal =
                  signalStrength && signalStrength.type !== "none";
                const signalStyle = getSignalStyle(signalStrength);

                // Hover style: use flash color for signal rows, default for others
                const hoverStyle =
                  hasSignal && signalStrength
                    ? {
                        backgroundColor:
                          signalStrength.type === "buy"
                            ? "rgba(180, 229, 89, 0.5)" // Flash green
                            : "rgba(239, 68, 68, 0.5)", // Flash red
                      }
                    : undefined;

                return (
                  <tr
                    key={row.id}
                    onClick={() => handleRowClick(row)}
                    className={cn(
                      "group cursor-pointer transition-colors",
                      // Default hover for non-signal rows
                      !hasSignal && "hover:bg-bg-quartiary",
                      // Alternating greys when no signal
                      !hasSignal &&
                        (index % 2 === 0
                          ? "bg-bg-tertiary"
                          : "bg-bg-primary-hover")
                    )}
                    style={hasSignal ? signalStyle : undefined}
                    onMouseEnter={e => {
                      if (hoverStyle) {
                        e.currentTarget.style.backgroundColor =
                          hoverStyle.backgroundColor;
                      }
                    }}
                    onMouseLeave={e => {
                      if (hasSignal && signalStyle) {
                        e.currentTarget.style.backgroundColor =
                          signalStyle.backgroundColor || "";
                      }
                    }}
                  >
                    {row.getVisibleCells().map((cell, cellIndex) => (
                      <td
                        key={cell.id}
                        className={cn(
                          "px-1 py-1 text-xs",
                          // Curved cells - rounded on first/last
                          cellIndex === 0 && "rounded-l",
                          cellIndex === row.getVisibleCells().length - 1 &&
                            "rounded-r",
                          // Inherit background for signal styling
                          "bg-inherit"
                        )}
                        style={{ width: cell.column.getSize() }}
                      >
                        {flexRender(
                          cell.column.columnDef.cell,
                          cell.getContext()
                        )}
                      </td>
                    ))}
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};

export default ScreenerTable;
