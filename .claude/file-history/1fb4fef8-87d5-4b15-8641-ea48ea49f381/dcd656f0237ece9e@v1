/**
 * Signal Processor
 *
 * Dual-path signal generation:
 * - Fast path: processMarketData() for simple rules (no OHLCV needed)
 * - Complex path: processOHLCV() for rules requiring candlestick data
 *
 * Both paths are synchronous - no API calls, keeps latency under 100ms.
 *
 * Implements ISignalProcessor - the LOIS-ready interface for future Rust reimplementation.
 */

import type { TokenMarketData, OHLCV } from '../api/types.js';
import type { Signal, AnalysisContext } from '../rules/types.js';
import type { ISignalProcessor } from '../types/index.js';
import { RuleEngine } from '../rules/engine.js';
import { validateTokenMarketData } from '../data/validator.js';
import { normalizeTokenMarketData } from '../data/normalizer.js';

export interface SignalProcessorOptions {
  /**
   * Optional function to look up market data by mint.
   * Used to enrich OHLCV processing context when marketData is not explicitly passed.
   */
  marketDataProvider?: () => Map<string, TokenMarketData>;
}

export class SignalProcessor {
  private engine: RuleEngine;
  private marketDataProvider?: () => Map<string, TokenMarketData>;

  constructor(engine: RuleEngine, options?: SignalProcessorOptions) {
    this.engine = engine;
    this.marketDataProvider = options?.marketDataProvider;
  }

  /**
   * Process market data and generate signals
   * Fast path: validate → normalize → filter simple rules → run rules → return signals
   * Only runs rules that don't require OHLCV data (simple rules)
   * @param data Incoming market data (potentially partial/dirty)
   * @returns Array of signals (empty if validation fails or no signals)
   */
  processMarketData(data: TokenMarketData): Signal[] {
    // Validate incoming data
    const validation = validateTokenMarketData(data);
    if (!validation.valid) {
      console.warn(`Invalid market data for ${data.mint}:`, validation.errors);
      return [];
    }

    // Normalize data (lowercase mint, fill defaults)
    const normalizedData = normalizeTokenMarketData(data);

    // Filter to only simple rules (those that don't require OHLCV)
    const allRules = this.engine.getRules();
    const simpleRules = allRules.filter(rule => rule.config.requiresOHLCV !== true);

    // Run only simple rules against market data
    const context = { token: normalizedData, ohlcv: [], trades: [] };
    const signals: Signal[] = [];

    try {
      for (const rule of simpleRules) {
        try {
          const signal = rule.analyze(context);
          if (signal) signals.push(signal);
        } catch (error) {
          console.error(`Rule ${rule.config.id} error:`, error);
        }
      }
      return signals;
    } catch (error) {
      console.error(`Error processing market data for ${normalizedData.mint}:`, error);
      return [];
    }
  }

  /**
   * Process OHLCV data and generate signals from complex rules
   * Complex path: filter OHLCV-requiring rules → build context → run rules → return signals
   * Only runs rules that require OHLCV data (rotations, fractals, etc.)
   *
   * @param mint Token mint address
   * @param ohlcv Array of OHLCV candles (at least 2 required for analysis)
   * @param marketData Optional market data for context enrichment
   * @returns Array of signals (empty if insufficient data or no signals)
   */
  processOHLCV(mint: string, ohlcv: OHLCV[], marketData?: TokenMarketData): Signal[] {
    // Validate OHLCV array (at least 2 candles required for rotations)
    if (!ohlcv || ohlcv.length < 2) {
      return [];
    }

    // Get rules that require OHLCV
    const allRules = this.engine.getRules();
    const ohlcvRules = allRules.filter(rule => rule.config.requiresOHLCV === true);

    if (ohlcvRules.length === 0) {
      return [];
    }

    // Build token context for AnalysisContext
    let token: TokenMarketData;

    if (marketData) {
      // Use provided market data
      token = marketData;
    } else if (this.marketDataProvider) {
      // Try to look up market data from provider
      const providerData = this.marketDataProvider().get(mint);
      if (providerData) {
        token = providerData;
      } else {
        // Create minimal stub from OHLCV data
        token = this.createMinimalTokenData(mint, ohlcv);
      }
    } else {
      // Create minimal stub from OHLCV data
      token = this.createMinimalTokenData(mint, ohlcv);
    }

    // Build analysis context with OHLCV
    const context: AnalysisContext = {
      token,
      ohlcv,
      trades: [], // Not needed for OHLCV-based rules
    };

    // Run OHLCV-requiring rules
    const signals: Signal[] = [];

    try {
      for (const rule of ohlcvRules) {
        try {
          const signal = rule.analyze(context);
          if (signal) signals.push(signal);
        } catch (error) {
          console.error(`Rule ${rule.config.id} error:`, error);
        }
      }
      return signals;
    } catch (error) {
      console.error(`Error processing OHLCV for ${mint}:`, error);
      return [];
    }
  }

  /**
   * Create minimal TokenMarketData stub from OHLCV data
   * Used when no market data is available but we still need to run OHLCV rules
   */
  private createMinimalTokenData(mint: string, ohlcv: OHLCV[]): TokenMarketData {
    const latestCandle = ohlcv[ohlcv.length - 1];
    const price = latestCandle?.close ?? 0;

    return {
      mint,
      symbol: 'UNKNOWN',
      name: 'Unknown Token',
      price_sol: price,
      price_usd: 0,
      market_cap_sol: 0,
      market_cap_usd: 0,
      holders: '0',
      // Volume metrics
      buy_volume_sol_5m: 0,
      sell_volume_sol_5m: 0,
      buy_volume_sol_1h: 0,
      sell_volume_sol_1h: 0,
      buy_volume_sol_6h: 0,
      sell_volume_sol_6h: 0,
      buy_volume_sol_24h: 0,
      sell_volume_sol_24h: 0,
      volume_24h_sol: 0,
      // Buy/sell counts
      buys_5m: 0,
      buys_1h: 0,
      buys_6h: 0,
      buys_24h: 0,
      sells_5m: 0,
      sells_1h: 0,
      sells_6h: 0,
      sells_24h: 0,
      // Trader counts
      buyers_5m: 0,
      buyers_1h: 0,
      buyers_6h: 0,
      buyers_24h: 0,
      sellers_5m: 0,
      sellers_1h: 0,
      sellers_6h: 0,
      sellers_24h: 0,
      traders_5m: 0,
      traders_1h: 0,
      traders_6h: 0,
      traders_24h: 0,
      // Price history
      earliest_price_sol_5m: price,
      earliest_price_sol_1h: price,
      earliest_price_sol_6h: price,
      earliest_price_sol_24h: price,
      // Liquidity and supply
      liquidity_sol: 0,
      liquidity_usd: 0,
      total_supply: 0,
      circulating_supply: 0,
    };
  }
}
