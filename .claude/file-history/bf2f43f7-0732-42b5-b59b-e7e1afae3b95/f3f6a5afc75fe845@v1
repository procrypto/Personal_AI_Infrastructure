/**
 * TrenchBench Shared Store
 *
 * Centralized state management for TrenchBench dashboard widgets (Intel Grid, Vantage, Anomalyzer).
 * Eliminates duplicate trade processing by providing shared indexes that all widgets subscribe to.
 *
 * Features:
 * - traderIndex: Aggregated metrics per trader (KOL/tracked/user)
 * - tokenIndex: Aggregated metrics per token
 * - holdingsMatrix: Current holdings (trader -> token -> amount)
 * - selectionState: Unified selection across widgets
 * - localStorage persistence with Map/Set serialization
 * - Source precedence: KOL > tracked > user
 */

import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import { enableMapSet } from "immer";
import type { LiveTrade } from "@/store/memoryStore/slices/wallet-tracking-store/types";
import type { HolderRow } from "@/api/local-api/holders-batch";

enableMapSet();

// =============================================================================
// Types
// =============================================================================

export type TraderSource = "kol" | "tracked" | "user";

export type ActivityEvent = {
  timestamp: number;
  type: "buy" | "sell";
  solAmount: number;
};

export type TraderMetrics = {
  address: string;
  name: string;
  icon: string | null;
  source: TraderSource;
  twitter: string | null;
  // Trade counts.
  buys: number;
  sells: number;
  // Volume.
  buyVolumeSol: number;
  sellVolumeSol: number;
  netPositionSol: number;
  // Performance.
  totalPnlUsd: number;
  avgMomentum: number;
  avgEntryMcUsd: number;
  // Timestamps.
  firstTradeTimestamp: number;
  lastTradeTimestamp: number;
  // Streaks.
  winStreak: number;
  lossStreak: number;
  // For momentum calculation.
  momentumSum: number;
  momentumVolume: number;
};

export type TokenMetrics = {
  mint: string;
  symbol: string;
  name: string;
  image: string;
  launchpad: string;
  currentMcUsd: number;
  // Aggregated stats.
  totalKolCount: number;
  totalTrackedCount: number;
  totalInvestedSol: number;
  avgEntryMcUsd: number;
  // Timestamps.
  firstEntryTimestamp: number;
  lastActivityTimestamp: number;
  addedAt: number;
  // Recent activity (last 5 min).
  recentBuys: number;
  recentSells: number;
  // Activity history for sparkline.
  activityHistory: ActivityEvent[];
  // Weighted entry MC for average calculation.
  entryMcSum: number;
  entryMcCount: number;
};

export type KolPosition = {
  kolAddress: string;
  kolName: string;
  kolEmoji: string;
  kolAvatar: string | null;
  kolTwitter: string | null;
  source: TraderSource;
  entryAmountSol: number;
  entryMcUsd: number;
  currentHoldingSol: number;
  entryTimestamp: number;
  lastTradeTimestamp: number;
  isBuying: boolean;
};

// Trader address -> Token mint -> Amount held.
export type HoldingsMatrix = Map<string, Map<string, number>>;

// Cost basis tracking for PnL calculation.
export type PositionCostBasis = {
  totalCostSol: number; // Total SOL spent buying this position
  totalTokens: number; // Total tokens acquired (for average cost calculation)
};

// Trader address -> Token mint -> Cost basis.
export type CostBasisMatrix = Map<string, Map<string, PositionCostBasis>>;

// Source priority for precedence logic.
const SOURCE_PRIORITY: Record<TraderSource, number> = {
  kol: 3,
  tracked: 2,
  user: 1,
};

// =============================================================================
// Store Types
// =============================================================================

type TrenchBenchState = {
  // Core indexes.
  traderIndex: Map<string, TraderMetrics>;
  tokenIndex: Map<string, TokenMetrics>;
  holdingsMatrix: HoldingsMatrix;
  costBasisMatrix: CostBasisMatrix; // For PnL calculation
  positionsByToken: Map<string, KolPosition[]>;

  // Selection state.
  selectedTokenMints: Set<string>;
  selectedTraderAddresses: Set<string>;

  // Metadata.
  lastSync: number;
  isHydrated: boolean;
  processedSignatures: Set<string>;
};

type TrenchBenchActions = {
  // Trade processing.
  processTrade: (trade: LiveTrade, source: TraderSource) => void;
  processTradesBatch: (trades: LiveTrade[], source: TraderSource) => void;

  // Holdings enrichment.
  enrichWithHolders: (holdersByMint: Record<string, HolderRow[]>) => void;

  // Selection.
  toggleToken: (mint: string) => void;
  toggleTrader: (address: string) => void;
  clearTokenSelections: () => void;
  clearTraderSelections: () => void;
  clearAllSelections: () => void;

  // Baseline derivation for Anomalyzer.
  getBaselineForTrader: (
    address: string
  ) => { trades: number; volume: number; avgEntryMc: number } | null;

  // Utilities.
  getTopTokenMints: (limit: number) => string[];
  markHydrated: () => void;
  reset: () => void;
};

export type TrenchBenchStore = TrenchBenchState & TrenchBenchActions;

// =============================================================================
// Initial State
// =============================================================================

const initialState: TrenchBenchState = {
  traderIndex: new Map(),
  tokenIndex: new Map(),
  holdingsMatrix: new Map(),
  costBasisMatrix: new Map(),
  positionsByToken: new Map(),
  selectedTokenMints: new Set(),
  selectedTraderAddresses: new Set(),
  lastSync: 0,
  isHydrated: false,
  processedSignatures: new Set(),
};

// =============================================================================
// Serialization Helpers for Map/Set
// =============================================================================

type SerializedMap = { __type: "Map"; entries: [string, unknown][] };
type SerializedSet = { __type: "Set"; values: string[] };
type SerializedHoldingsMatrix = {
  __type: "HoldingsMatrix";
  entries: [string, [string, number][]][];
};
type SerializedCostBasisMatrix = {
  __type: "CostBasisMatrix";
  entries: [string, [string, PositionCostBasis][]][];
};

const isSerializedMap = (value: unknown): value is SerializedMap =>
  typeof value === "object" &&
  value !== null &&
  (value as SerializedMap).__type === "Map";

const isSerializedSet = (value: unknown): value is SerializedSet =>
  typeof value === "object" &&
  value !== null &&
  (value as SerializedSet).__type === "Set";

const isSerializedHoldingsMatrix = (
  value: unknown
): value is SerializedHoldingsMatrix =>
  typeof value === "object" &&
  value !== null &&
  (value as SerializedHoldingsMatrix).__type === "HoldingsMatrix";

const isSerializedCostBasisMatrix = (
  value: unknown
): value is SerializedCostBasisMatrix =>
  typeof value === "object" &&
  value !== null &&
  (value as SerializedCostBasisMatrix).__type === "CostBasisMatrix";

const serializeState = (state: TrenchBenchState) => ({
  traderIndex: {
    __type: "Map",
    entries: Array.from(state.traderIndex.entries()),
  },
  tokenIndex: {
    __type: "Map",
    entries: Array.from(state.tokenIndex.entries()),
  },
  holdingsMatrix: {
    __type: "HoldingsMatrix",
    entries: Array.from(state.holdingsMatrix.entries()).map(
      ([trader, tokens]) => [trader, Array.from(tokens.entries())] as const
    ),
  },
  costBasisMatrix: {
    __type: "CostBasisMatrix",
    entries: Array.from(state.costBasisMatrix.entries()).map(
      ([trader, positions]) => [trader, Array.from(positions.entries())] as const
    ),
  },
  positionsByToken: {
    __type: "Map",
    entries: Array.from(state.positionsByToken.entries()),
  },
  selectedTokenMints: {
    __type: "Set",
    values: Array.from(state.selectedTokenMints),
  },
  selectedTraderAddresses: {
    __type: "Set",
    values: Array.from(state.selectedTraderAddresses),
  },
  lastSync: state.lastSync,
  isHydrated: state.isHydrated,
  // Don't persist processedSignatures - too large.
});

const deserializeState = (
  persisted: unknown
): Partial<TrenchBenchState> | null => {
  if (!persisted || typeof persisted !== "object") {
    return null;
  }

  const p = persisted as Record<string, unknown>;

  const result: Partial<TrenchBenchState> = {};

  if (isSerializedMap(p.traderIndex)) {
    result.traderIndex = new Map(
      p.traderIndex.entries as [string, TraderMetrics][]
    );
  }

  if (isSerializedMap(p.tokenIndex)) {
    result.tokenIndex = new Map(
      p.tokenIndex.entries as [string, TokenMetrics][]
    );
  }

  if (isSerializedHoldingsMatrix(p.holdingsMatrix)) {
    const matrix = new Map<string, Map<string, number>>();
    for (const [trader, tokens] of p.holdingsMatrix.entries) {
      matrix.set(trader, new Map(tokens));
    }
    result.holdingsMatrix = matrix;
  }

  if (isSerializedCostBasisMatrix(p.costBasisMatrix)) {
    const matrix = new Map<string, Map<string, PositionCostBasis>>();
    for (const [trader, positions] of p.costBasisMatrix.entries) {
      matrix.set(trader, new Map(positions));
    }
    result.costBasisMatrix = matrix;
  }

  if (isSerializedMap(p.positionsByToken)) {
    result.positionsByToken = new Map(
      p.positionsByToken.entries as [string, KolPosition[]][]
    );
  }

  if (isSerializedSet(p.selectedTokenMints)) {
    result.selectedTokenMints = new Set(p.selectedTokenMints.values);
  }

  if (isSerializedSet(p.selectedTraderAddresses)) {
    result.selectedTraderAddresses = new Set(p.selectedTraderAddresses.values);
  }

  if (typeof p.lastSync === "number") {
    result.lastSync = p.lastSync;
  }

  if (typeof p.isHydrated === "boolean") {
    result.isHydrated = p.isHydrated;
  }

  return result;
};

// =============================================================================
// Constants
// =============================================================================

const FIVE_MINUTES = 5 * 60 * 1000;
const TWO_HOURS = 2 * 60 * 60 * 1000;
const STALENESS_THRESHOLD = 30 * 60 * 1000; // 30 minutes.

// Timestamp thresholds for unit detection.
// Milliseconds: 13 digits (year 2001-2286).
// Microseconds: 16 digits.
// Nanoseconds: 19 digits.
const MS_THRESHOLD = 1e13; // Values above this are not milliseconds.
const US_THRESHOLD = 1e16; // Values above this are nanoseconds.

/**
 * Normalize timestamp to milliseconds.
 * Handles nanoseconds, microseconds, and milliseconds.
 */
const normalizeTimestamp = (ts: unknown): number => {
  let value: number;
  if (typeof ts === "number") {
    value = ts;
  }
  else if (typeof ts === "string") {
    value = parseInt(ts, 10);
  }
  else {
    return Date.now();
  }

  if (Number.isNaN(value) || value <= 0) {
    return Date.now();
  }

  // Nanoseconds (19 digits) -> divide by 1,000,000.
  if (value > US_THRESHOLD) {
    return Math.floor(value / 1_000_000);
  }

  // Microseconds (16 digits) -> divide by 1,000.
  if (value > MS_THRESHOLD) {
    return Math.floor(value / 1_000);
  }

  // Already milliseconds.
  return value;
};

// =============================================================================
// Store Creation
// =============================================================================

export const useTrenchBenchStore = create<TrenchBenchStore>()(
  persist(
    immer((set, get) => ({
      ...initialState,

      processTrade: (trade: LiveTrade, source: TraderSource) => {
        set(state => {
          processTradeInternal(state, trade, source);
          state.lastSync = Date.now();
        });
      },

      processTradesBatch: (trades: LiveTrade[], source: TraderSource) => {
        set(state => {
          for (const trade of trades) {
            processTradeInternal(state, trade, source);
          }
          state.lastSync = Date.now();
        });
      },

      enrichWithHolders: (holdersByMint: Record<string, HolderRow[]>) => {
        set(state => {
          for (const [mint, holders] of Object.entries(holdersByMint)) {
            for (const holder of holders) {
              const traderHoldings = state.holdingsMatrix.get(holder.address);
              if (traderHoldings) {
                const actualAmount = parseFloat(holder.remaining_tokens) || 0;
                if (actualAmount > 0) {
                  traderHoldings.set(mint, actualAmount);
                }
                else {
                  traderHoldings.delete(mint);
                }
              }
            }
          }
          state.lastSync = Date.now();
        });
      },

      toggleToken: (mint: string) => {
        set(state => {
          const mintLower = mint.toLowerCase();
          if (state.selectedTokenMints.has(mintLower)) {
            state.selectedTokenMints.delete(mintLower);
          }
          else {
            state.selectedTokenMints.add(mintLower);
          }
        });
      },

      toggleTrader: (address: string) => {
        set(state => {
          const addrLower = address.toLowerCase();
          if (state.selectedTraderAddresses.has(addrLower)) {
            state.selectedTraderAddresses.delete(addrLower);
          }
          else {
            state.selectedTraderAddresses.add(addrLower);
          }
        });
      },

      clearTokenSelections: () => {
        set(state => {
          state.selectedTokenMints.clear();
        });
      },

      clearTraderSelections: () => {
        set(state => {
          state.selectedTraderAddresses.clear();
        });
      },

      clearAllSelections: () => {
        set(state => {
          state.selectedTokenMints.clear();
          state.selectedTraderAddresses.clear();
        });
      },

      getBaselineForTrader: (address: string) => {
        const state = get();
        const trader = state.traderIndex.get(address.toLowerCase());
        if (!trader) {
          return null;
        }
        return {
          trades: trader.buys + trader.sells,
          volume: trader.buyVolumeSol + trader.sellVolumeSol,
          avgEntryMc: trader.avgEntryMcUsd,
        };
      },

      getTopTokenMints: (limit: number) => {
        const state = get();
        return Array.from(state.tokenIndex.values())
          .sort((a, b) => b.totalKolCount - a.totalKolCount)
          .slice(0, limit)
          .map(t => t.mint);
      },

      markHydrated: () => {
        set(state => {
          state.isHydrated = true;
        });
      },

      reset: () => {
        set(() => ({ ...initialState, isHydrated: true }));
      },
    })),
    {
      name: "trenchbench",
      storage: createJSONStorage(() => localStorage, {
        replacer: (_key, value) => {
          // Custom serialization is handled by partialize.
          return value;
        },
        reviver: (_key, value) => {
          // Custom deserialization is handled by merge.
          return value;
        },
      }),
      partialize: state => serializeState(state),
      merge: (persisted, current) => {
        const deserialized = deserializeState(persisted);
        if (!deserialized) {
          return { ...current, isHydrated: true };
        }

        // Check staleness.
        const now = Date.now();
        const lastSync = deserialized.lastSync ?? 0;
        if (now - lastSync > STALENESS_THRESHOLD) {
          // Stale data - keep selections but clear indexes.
          return {
            ...current,
            selectedTokenMints:
              deserialized.selectedTokenMints ?? new Set<string>(),
            selectedTraderAddresses:
              deserialized.selectedTraderAddresses ?? new Set<string>(),
            isHydrated: true,
          };
        }

        return {
          ...current,
          ...deserialized,
          processedSignatures: new Set<string>(),
          isHydrated: true,
        };
      },
    }
  )
);

// =============================================================================
// Internal Trade Processing
// =============================================================================

const processTradeInternal = (
  state: TrenchBenchState,
  trade: LiveTrade,
  source: TraderSource
) => {
  // Skip if already processed.
  if (!trade.signature) {
    return;
  }
  if (state.processedSignatures.has(trade.signature)) {
    return;
  }
  state.processedSignatures.add(trade.signature);

  const makerLower = trade.maker?.toLowerCase();
  const mintLower = trade.mint?.toLowerCase();
  if (!makerLower || !mintLower) {
    return;
  }

  const isBuy = trade.type === "buy";
  // sol_amount from backend might be in lamports or human-readable SOL
  // Detect format: if it's a large integer (>= 1 million, no decimal), it's lamports
  const rawSolStr = trade.sol_amount || "0";
  const rawSol = parseFloat(rawSolStr);
  const isLikelyLamports = rawSol >= 1_000_000 && !rawSolStr.includes(".");
  const solAmount = isLikelyLamports ? rawSol / 1_000_000_000 : rawSol;
  const mcUsd = parseFloat(trade.market_cap_usd || "0") || 0;
  const tradeTimestamp = normalizeTimestamp(trade.timestamp);
  const now = Date.now();

  // Update trader index.
  let trader = state.traderIndex.get(makerLower);
  if (!trader) {
    trader = createTraderMetrics(makerLower, trade, source, tradeTimestamp);
    state.traderIndex.set(makerLower, trader);
  }
  else {
    // Check source precedence.
    if (SOURCE_PRIORITY[source] > SOURCE_PRIORITY[trader.source]) {
      // Upgrade source and update name/icon.
      trader.source = source;
      trader.name = trade.token_symbol || trader.name;
    }
  }

  // Update trade metrics.
  if (isBuy) {
    trader.buys += 1;
    trader.buyVolumeSol += solAmount;
  }
  else {
    trader.sells += 1;
    trader.sellVolumeSol += solAmount;
  }
  trader.netPositionSol = trader.buyVolumeSol - trader.sellVolumeSol;
  trader.lastTradeTimestamp = Math.max(trader.lastTradeTimestamp, tradeTimestamp);

  // Momentum calculation.
  if (isBuy && mcUsd > 0) {
    trader.momentumSum += solAmount * mcUsd;
    trader.momentumVolume += solAmount;
    if (trader.momentumVolume > 0) {
      trader.avgMomentum = trader.momentumSum / trader.momentumVolume;
    }
    // Update avg entry MC.
    if (trader.avgEntryMcUsd === 0) {
      trader.avgEntryMcUsd = mcUsd;
    }
    else {
      trader.avgEntryMcUsd = (trader.avgEntryMcUsd + mcUsd) / 2;
    }
  }

  // Update token index.
  let token = state.tokenIndex.get(mintLower);
  if (!token) {
    token = createTokenMetrics(mintLower, trade, tradeTimestamp);
    state.tokenIndex.set(mintLower, token);
  }

  token.currentMcUsd = mcUsd || token.currentMcUsd;
  token.lastActivityTimestamp = Math.max(
    token.lastActivityTimestamp,
    tradeTimestamp
  );

  // Track recent activity.
  if (now - tradeTimestamp < FIVE_MINUTES) {
    if (isBuy) {
      token.recentBuys += 1;
    }
    else {
      token.recentSells += 1;
    }
  }

  // Update activity history (keep last 2 hours).
  const twoHoursAgo = now - TWO_HOURS;
  token.activityHistory = token.activityHistory.filter(
    e => e.timestamp > twoHoursAgo
  );
  token.activityHistory.push({
    timestamp: tradeTimestamp,
    type: isBuy ? "buy" : "sell",
    solAmount,
  });

  // Track KOL/tracked count and investment.
  if (isBuy) {
    if (source === "kol") {
      // Check if this KOL already counted for this token.
      const existingHolding = state.holdingsMatrix.get(makerLower)?.get(mintLower);
      if (!existingHolding || existingHolding === 0) {
        token.totalKolCount += 1;
      }
    }
    else if (source === "tracked") {
      const existingHolding = state.holdingsMatrix.get(makerLower)?.get(mintLower);
      if (!existingHolding || existingHolding === 0) {
        token.totalTrackedCount += 1;
      }
    }
    token.totalInvestedSol += solAmount;

    // Update avg entry MC.
    if (mcUsd > 0) {
      token.entryMcSum += mcUsd;
      token.entryMcCount += 1;
      token.avgEntryMcUsd = token.entryMcSum / token.entryMcCount;
    }
  }

  // Update holdings matrix.
  let traderHoldings = state.holdingsMatrix.get(makerLower);
  if (!traderHoldings) {
    traderHoldings = new Map();
    state.holdingsMatrix.set(makerLower, traderHoldings);
  }

  const currentHolding = traderHoldings.get(mintLower) || 0;
  const tokenAmount = parseFloat(trade.token_amount || "0") || 0;
  const newHolding = isBuy
    ? currentHolding + tokenAmount
    : currentHolding - tokenAmount;

  // =========================================================================
  // Cost Basis Tracking & PnL Calculation
  // =========================================================================
  let traderCostBasis = state.costBasisMatrix.get(makerLower);
  if (!traderCostBasis) {
    traderCostBasis = new Map();
    state.costBasisMatrix.set(makerLower, traderCostBasis);
  }

  let positionCostBasis = traderCostBasis.get(mintLower) || {
    totalCostSol: 0,
    totalTokens: 0,
  };

  if (isBuy) {
    // Add to cost basis when buying
    positionCostBasis = {
      totalCostSol: positionCostBasis.totalCostSol + solAmount,
      totalTokens: positionCostBasis.totalTokens + tokenAmount,
    };
    traderCostBasis.set(mintLower, positionCostBasis);
  } else {
    // Calculate realized PnL when selling
    if (positionCostBasis.totalTokens > 0 && tokenAmount > 0) {
      // Average cost per token in SOL
      const avgCostPerToken =
        positionCostBasis.totalCostSol / positionCostBasis.totalTokens;
      // Cost of tokens being sold
      const costOfSoldTokens = avgCostPerToken * tokenAmount;
      // Realized PnL for this sale (in SOL)
      const realizedPnlSol = solAmount - costOfSoldTokens;
      // Convert to USD using current market cap as price reference
      // (rough estimate: sol_amount_usd field if available, otherwise use solAmount * ~100)
      const solPriceUsd = parseFloat(trade.sol_amount_usd || "0") / solAmount || 100;
      const realizedPnlUsd = realizedPnlSol * solPriceUsd;

      // Update trader's total PnL
      trader.totalPnlUsd += realizedPnlUsd;

      // Update cost basis (reduce proportionally)
      const remainingTokens = Math.max(
        0,
        positionCostBasis.totalTokens - tokenAmount
      );
      if (remainingTokens > 0) {
        // Proportionally reduce cost basis
        const fractionRemaining =
          remainingTokens / positionCostBasis.totalTokens;
        positionCostBasis = {
          totalCostSol: positionCostBasis.totalCostSol * fractionRemaining,
          totalTokens: remainingTokens,
        };
        traderCostBasis.set(mintLower, positionCostBasis);
      } else {
        // Position fully closed
        traderCostBasis.delete(mintLower);
      }
    }
  }
  // =========================================================================

  if (newHolding > 0) {
    traderHoldings.set(mintLower, newHolding);
  }
  else {
    traderHoldings.delete(mintLower);
    // Decrement KOL/tracked count when position is fully sold.
    if (source === "kol") {
      token.totalKolCount = Math.max(0, token.totalKolCount - 1);
    }
    else if (source === "tracked") {
      token.totalTrackedCount = Math.max(0, token.totalTrackedCount - 1);
    }
  }

  updateKolPositions({
    state,
    mintLower,
    makerLower,
    solAmount,
    marketCapUsd: mcUsd,
    tradeTimestamp,
    isBuy,
    source,
  });
};

const createTraderMetrics = (
  address: string,
  trade: LiveTrade,
  source: TraderSource,
  timestamp: number
): TraderMetrics => ({
  address,
  name: trade.token_symbol || address.slice(0, 8),
  icon: null,
  source,
  twitter: null,
  buys: 0,
  sells: 0,
  buyVolumeSol: 0,
  sellVolumeSol: 0,
  netPositionSol: 0,
  totalPnlUsd: 0,
  avgMomentum: 0,
  avgEntryMcUsd: 0,
  firstTradeTimestamp: timestamp,
  lastTradeTimestamp: timestamp,
  winStreak: 0,
  lossStreak: 0,
  momentumSum: 0,
  momentumVolume: 0,
});

const createTokenMetrics = (
  mint: string,
  trade: LiveTrade,
  timestamp: number
): TokenMetrics => ({
  mint: trade.mint || mint,
  symbol: trade.token_symbol || "???",
  name: trade.token_name || trade.token_symbol || "Unknown",
  image: trade.token_image || "",
  launchpad: trade.launchpad || "",
  currentMcUsd: parseFloat(trade.market_cap_usd || "0") || 0,
  totalKolCount: 0,
  totalTrackedCount: 0,
  totalInvestedSol: 0,
  avgEntryMcUsd: 0,
  firstEntryTimestamp: timestamp,
  lastActivityTimestamp: timestamp,
  addedAt: Date.now(),
  recentBuys: 0,
  recentSells: 0,
  activityHistory: [],
  entryMcSum: 0,
  entryMcCount: 0,
});

type UpdateKolPositionsArgs = {
  state: TrenchBenchState;
  mintLower: string;
  makerLower: string;
  solAmount: number;
  marketCapUsd: number;
  tradeTimestamp: number;
  isBuy: boolean;
  source: TraderSource;
};

const updateKolPositions = ({
  state,
  mintLower,
  makerLower,
  solAmount,
  marketCapUsd,
  tradeTimestamp,
  isBuy,
  source,
}: UpdateKolPositionsArgs) => {
  if (source === "user") {
    return;
  }

  let positions = state.positionsByToken.get(mintLower);
  if (!positions) {
    positions = [];
    state.positionsByToken.set(mintLower, positions);
  }

  let position = positions.find(pos => pos.kolAddress === makerLower);
  if (!position) {
    position = {
      kolAddress: makerLower,
      kolName: `Wallet ${makerLower.slice(0, 4)}...`,
      kolEmoji: "",
      kolAvatar: null,
      kolTwitter: null,
      source,
      entryAmountSol: 0,
      entryMcUsd: marketCapUsd,
      currentHoldingSol: 0,
      entryTimestamp: tradeTimestamp,
      lastTradeTimestamp: tradeTimestamp,
      isBuying: isBuy,
    };
    positions.push(position);
  }

  if (isBuy) {
    const previousEntryAmount = position.entryAmountSol;
    position.entryAmountSol += solAmount;
    position.currentHoldingSol += solAmount;
    const totalEntry = previousEntryAmount + solAmount;
    if (totalEntry > 0) {
      position.entryMcUsd =
        (position.entryMcUsd * previousEntryAmount + marketCapUsd * solAmount) /
        totalEntry;
    }
    else {
      position.entryMcUsd = marketCapUsd;
    }
  }
  else {
    position.currentHoldingSol = Math.max(0, position.currentHoldingSol - solAmount);
  }

  position.isBuying = isBuy;
  position.lastTradeTimestamp = tradeTimestamp;

  if (position.currentHoldingSol <= 0 && !isBuy) {
    const index = positions.findIndex(pos => pos.kolAddress === makerLower);
    if (index >= 0) {
      positions.splice(index, 1);
    }
    if (positions.length === 0) {
      state.positionsByToken.delete(mintLower);
    }
  }
};

// =============================================================================
// Utility Exports
// =============================================================================

export const isTrenchBenchStateStale = (): boolean => {
  const state = useTrenchBenchStore.getState();
  return Date.now() - state.lastSync > STALENESS_THRESHOLD;
};

export const getTrenchBenchStateAge = (): number => {
  const state = useTrenchBenchStore.getState();
  return Date.now() - state.lastSync;
};

// =============================================================================
// Debug Helper - Expose store for console debugging
// =============================================================================

// Expose store on window for debugging in development
if (typeof window !== "undefined") {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (window as any).__TRENCHBENCH_STORE__ = {
    get state() {
      return useTrenchBenchStore.getState();
    },
    get traderIndex() {
      return useTrenchBenchStore.getState().traderIndex;
    },
    get tokenIndex() {
      return useTrenchBenchStore.getState().tokenIndex;
    },
    get holdingsMatrix() {
      return useTrenchBenchStore.getState().holdingsMatrix;
    },
    get costBasisMatrix() {
      return useTrenchBenchStore.getState().costBasisMatrix;
    },
    get selectedTokenMints() {
      return useTrenchBenchStore.getState().selectedTokenMints;
    },
    get lastSync() {
      return new Date(useTrenchBenchStore.getState().lastSync).toLocaleString();
    },
    summary() {
      const s = useTrenchBenchStore.getState();
      console.log("=== TrenchBench Store Summary ===");
      console.log("Traders:", s.traderIndex.size);
      console.log("Tokens:", s.tokenIndex.size);
      console.log("Holdings entries:", s.holdingsMatrix.size);
      console.log("Cost basis entries:", s.costBasisMatrix.size);
      console.log("Selected tokens:", s.selectedTokenMints.size);
      console.log("Last sync:", new Date(s.lastSync).toLocaleString());
      console.log("Is hydrated:", s.isHydrated);
      return s;
    },
  };
}

