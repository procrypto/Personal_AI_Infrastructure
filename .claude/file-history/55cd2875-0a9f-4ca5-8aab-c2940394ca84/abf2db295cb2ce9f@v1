/**
 * Configuration Store
 *
 * Handles loading and saving user configuration.
 */

import { readFile, writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname } from 'path';
import type { UserConfig, WatchlistToken } from './types.js';
import { DEFAULT_CONFIG } from './types.js';
import type { RuleSet } from '../rules/types.js';

const CONFIG_DIR = join(process.cwd(), '.autopilot');
const CONFIG_FILE = join(CONFIG_DIR, 'config.json');

export class ConfigStore {
  private config: UserConfig;

  constructor() {
    this.config = { ...DEFAULT_CONFIG };
  }

  async load(): Promise<UserConfig> {
    try {
      if (existsSync(CONFIG_FILE)) {
        const data = await readFile(CONFIG_FILE, 'utf-8');
        this.config = { ...DEFAULT_CONFIG, ...JSON.parse(data) };
      }
    } catch (error) {
      console.warn('Failed to load config, using defaults:', error);
      this.config = { ...DEFAULT_CONFIG };
    }
    return this.config;
  }

  async save(): Promise<void> {
    try {
      if (!existsSync(CONFIG_DIR)) {
        await mkdir(CONFIG_DIR, { recursive: true });
      }
      this.config.updatedAt = Date.now();
      await writeFile(CONFIG_FILE, JSON.stringify(this.config, null, 2));
    } catch (error) {
      console.error('Failed to save config:', error);
      throw error;
    }
  }

  get(): UserConfig {
    return this.config;
  }

  // Watchlist management
  addToWatchlist(mint: string, symbol?: string, name?: string): void {
    if (this.config.watchlist.some(t => t.mint === mint)) {
      return; // Already exists
    }
    this.config.watchlist.push({
      mint,
      symbol,
      name,
      addedAt: Date.now(),
    });
  }

  removeFromWatchlist(mint: string): boolean {
    const index = this.config.watchlist.findIndex(t => t.mint === mint);
    if (index === -1) return false;
    this.config.watchlist.splice(index, 1);
    return true;
  }

  getWatchlist(): WatchlistToken[] {
    return this.config.watchlist;
  }

  // Rule set management
  addRuleSet(ruleSet: RuleSet): void {
    const existing = this.config.ruleSets.findIndex(r => r.id === ruleSet.id);
    if (existing !== -1) {
      this.config.ruleSets[existing] = ruleSet;
    } else {
      this.config.ruleSets.push(ruleSet);
    }
  }

  removeRuleSet(id: string): boolean {
    const index = this.config.ruleSets.findIndex(r => r.id === id);
    if (index === -1) return false;
    this.config.ruleSets.splice(index, 1);
    return true;
  }

  getRuleSets(): RuleSet[] {
    return this.config.ruleSets;
  }

  // Trigger settings
  setTriggerMode(mode: 'paper' | 'live'): void {
    this.config.trigger.mode = mode;
  }

  setTriggerEnabled(enabled: boolean): void {
    this.config.trigger.enabled = enabled;
  }

  setPositionSize(sizeSol: number): void {
    this.config.trigger.defaultPositionSizeSol = sizeSol;
  }

  getTriggerConfig() {
    return this.config.trigger;
  }
}

// Singleton instance
export const configStore = new ConfigStore();
