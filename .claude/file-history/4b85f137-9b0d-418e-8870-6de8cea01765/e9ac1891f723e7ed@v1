import { sentryVitePlugin } from "@sentry/vite-plugin";
import tailwindcss from "@tailwindcss/vite";
import react from "@vitejs/plugin-react";
import path from "path";
import pkg from "./package.json";
import { defineConfig, loadEnv } from "vite";
import svgr from "vite-plugin-svgr";
import { execSync, spawn, type ChildProcess } from "child_process";
import { lingui } from "@lingui/vite-plugin";
import { tanstackRouter } from "@tanstack/router-plugin/vite";
import mkcert from "vite-plugin-mkcert";
import fs from "fs";

export default ({ mode }: { mode: string }) => {
  process.env = { ...process.env, ...loadEnv(mode, __dirname) };
  // Include the app name, version, and commit hash to easily see errors across
  // releases and environments in the Sentry dashboard.
  //  Example: "bonkbot-web-terminal@0.0.29-d06b94364c"
  // Note: Using '-' instead of '+' because Sentry CLI doesn't allow '+' in release versions

  const getCommitHash = () => {
    try {
      return (
        process.env.VERCEL_GIT_COMMIT_SHA?.slice(0, 10) ??
        execSync("git rev-parse --short=10 HEAD").toString().trim()
      );
    } catch {
      // Fallback when git is not available or not in a git repository
      return "unknown";
    }
  };

  // Sanitize release name: remove @ symbol and replace / with - for Sentry CLI compatibility
  // Format: bonkbot-web-terminal-1.0.14b-a44697aa23
  const releaseName = `${pkg.name.replace("@", "").replace(/\//g, "-")}-${pkg.version}-${getCommitHash()}`;

  // Plugin to generate version.json file for runtime version checking
  const versionPlugin = () => ({
    name: "version-plugin",
    writeBundle() {
      const versionFile = path.resolve(__dirname, "dist/version.json");
      fs.writeFileSync(
        versionFile,
        JSON.stringify({ version: releaseName }, null, 2)
      );
    },
  });

  const htmlEnvPlugin = () => ({
    name: "html-env-plugin",
    transformIndexHtml(html: string) {
      return html
        .replace(/%VITE_SENTRY_DSN%/g, process.env.VITE_SENTRY_DSN || "")
        .replace(/%VITE_APP_ENV%/g, process.env.VITE_APP_ENV || "")
        .replace(
          /%VERCEL_DEPLOYMENT_ID%/g,
          process.env.VERCEL_DEPLOYMENT_ID || ""
        );
    },
  });

  // Plugin to auto-start autopilot backend in local development
  const autopilotStartupPlugin = () => {
    let autopilotProcess: ChildProcess | null = null;

    return {
      name: "autopilot-startup-plugin",
      configureServer(server: {
        httpServer?: { on: (event: string, callback: () => void) => void };
      }) {
        // Only run in local development
        if (process.env.VITE_APP_ENV !== "local") return;

        const autopilotPath = path.resolve(
          __dirname,
          "../../token-analysis-autopilot"
        );

        // Check if autopilot directory exists
        if (!fs.existsSync(autopilotPath)) {
          console.log(
            "[Autopilot] âš ï¸  token-analysis-autopilot not found at",
            autopilotPath
          );
          console.log(
            "[Autopilot] Skipping auto-start. Run autopilot backend manually if needed."
          );
          return;
        }

        // Check for new engine mode via env var
        const useNewEngine = process.env.AUTOPILOT_NEW_ENGINE === "true";
        const args = ["tsx", "src/cli.ts", "run"];
        if (useNewEngine) {
          args.push("--new-engine");
        }

        console.log(
          `[Autopilot] ðŸš€ Starting autopilot backend...${useNewEngine ? " (new engine only)" : ""}`
        );

        autopilotProcess = spawn("npx", args, {
          cwd: autopilotPath,
          stdio: ["ignore", "pipe", "pipe"],
          shell: true,
        });

        autopilotProcess.stdout?.on("data", (data: Buffer) => {
          const lines = data.toString().trim().split("\n");
          lines.forEach((line: string) => console.log(`[Autopilot] ${line}`));
        });

        autopilotProcess.stderr?.on("data", (data: Buffer) => {
          const lines = data.toString().trim().split("\n");
          lines.forEach((line: string) => console.error(`[Autopilot] ${line}`));
        });

        autopilotProcess.on("error", (err: Error) => {
          console.error("[Autopilot] âŒ Failed to start:", err.message);
        });

        autopilotProcess.on("exit", (code: number | null) => {
          if (code !== null && code !== 0) {
            console.log(`[Autopilot] Process exited with code ${code}`);
          }
        });

        // Kill autopilot process when dev server stops
        server.httpServer?.on("close", () => {
          if (autopilotProcess) {
            console.log("[Autopilot] ðŸ›‘ Stopping autopilot backend...");
            autopilotProcess.kill("SIGTERM");
            autopilotProcess = null;
          }
        });
      },
    };
  };

  return defineConfig({
    // Set esbuild target for development transforms
    esbuild: {
      target: "es2020",
      // Suppress import.meta warnings - they're harmless as import.meta works at runtime
      logOverride: {
        "empty-import-meta": "silent",
      },
    },
    plugins: [
      htmlEnvPlugin(),
      tanstackRouter({
        target: "react",
        autoCodeSplitting: false,
        generatedRouteTree: "src/routes/routeTree.gen.ts",
        quoteStyle: "double",
        disableLogging: process.env.VITE_APP_ENV === "local",
      }),
      react({
        babel: {
          plugins: [
            "babel-plugin-react-compiler",
            "@lingui/babel-plugin-lingui-macro",
            ["@babel/plugin-proposal-decorators", { legacy: true }],
          ],
        },
      }),
      tailwindcss(),
      lingui(),
      svgr({
        // svgr options: https://react-svgr.com/docs/options/
        svgrOptions: {
          exportType: "default",
          ref: true,
          svgo: false,
          titleProp: true,
        },
        include: "**/*.svg",
      }),
      sentryVitePlugin({
        org: process.env.SENTRY_ORG,
        // Reduce verbosity for faster uploads
        debug: false,
        silent: true,
        project: process.env.SENTRY_PROJECT,
        authToken: process.env.SENTRY_AUTH_TOKEN,
        telemetry: false, // Disable telemetry for faster uploads
        sourcemaps: {
          // Delete sourcemaps in production
          filesToDeleteAfterUpload:
            process.env.VITE_APP_ENV === "prod" ||
            process.env.VITE_APP_ENV === "staging"
              ? ["**/dist/**/*.map"]
              : [],

          ignore: [
            // charting library is a raw, minified js library that gets copied
            // over from the public/ folder.  It has no sourcemaps, nor should
            // we try to generate one for it.
            "**/charting_library/**/*",
            // datafeeds is not a minified js library, but since it lives in
            // public/ it doesn't get sourcemaps.
            "**/datafeeds/**/*",
          ],
        },
        release: {
          name: releaseName,

          setCommits: {
            auto: true,
            ignoreMissing: true, // Ignore missing commits to avoid errors in CI/CD
            ignoreEmpty: true, // Ignore empty commits to avoid errors in CI/CD
          },
          deploy: {
            env: process.env.VITE_APP_ENV || "local",
          },
        },
        errorHandler: error => {
          console.error("âŒ Sentry sourcemap upload failed:", error.message);
          throw error; // Re-throw to fail the build
        },
      }),
      process.env.VITE_APP_ENV === "local" ? mkcert() : undefined,
      process.env.VITE_APP_ENV === "local"
        ? autopilotStartupPlugin()
        : undefined,
      versionPlugin(),
    ],
    resolve: {
      alias: {
        "@": path.resolve(__dirname, "./src"),
        "@bonkbot/telemetry": path.resolve(__dirname, "./src"),
        "@pvp": path.resolve(__dirname, "../../packages/pvp/src"),
      },
      dedupe: ["react", "react-dom"],
    },
    server: {
      https: process.env.VITE_APP_ENV === "local" ? {} : undefined,
      port: 3000,
      proxy: {
        "/v1": {
          target: process.env.VITE_API_URL,
          changeOrigin: true,
          secure: process.env.VITE_API_URL?.startsWith("https://") ?? false,
          ws: true,
        },
        "/data": {
          target: process.env.VITE_DATA_API_URL,
          changeOrigin: true,
          secure:
            process.env.VITE_DATA_API_URL?.startsWith("https://") ?? false,
          ws: true,
        },
        // Autopilot WebSocket proxy (local dev)
        "/autopilot-ws": {
          target: "ws://localhost:8765",
          changeOrigin: true,
          ws: true,
          rewrite: path => path.replace(/^\/autopilot-ws/, ""),
        },
      },
    },
    preview: {
      https: process.env.VITE_APP_ENV === "local" ? {} : undefined,
      port: 3000,
    },
    build: {
      sourcemap: true,
      cssCodeSplit: false,
      target: "es2020",
      // rollupOptions: {
      //   output: {
      //     manualChunks: (id: string) => {
      //       if (id.includes("node_modules")) {
      //         if (
      //           id.includes("react") ||
      //           id.includes("react-dom") ||
      //           id.includes("react-router-dom")
      //         ) {
      //           return "react-vendor";
      //         }
      //         if (id.includes("@radix-ui")) {
      //           return "radix-ui";
      //         }
      //         if (id.includes("@tanstack")) {
      //           return "tanstack";
      //         }

      //         return "vendor";
      //       }
      //     },
      //   },
      // },
    },
    define: {
      __RELEASE_NAME__: JSON.stringify(releaseName),
    },
  });
};
