     1→/**
     2→ * useAutopilotTokensWithPrices
     3→ *
     4→ * Combines autopilot token lists with NATS market data to provide
     5→ * live price and change data. Follows the same pattern as useAutopilotPositions.
     6→ *
     7→ * Token sources:
     8→ * - Watchlist: From autopilot backend (user-added tokens)
     9→ * - Whale moves: From Discovery API (1s refresh)
    10→ * - Trending: From Discovery API
    11→ */
    12→
    13→import { useMemo } from "react";
    14→import { useGlobalStore, useShallow } from "@/store/memoryStore/useGlobalStore";
    15→import type { AutopilotWatchedToken } from "@/store/memoryStore/slices/autopilot-store/types";
    16→import { useAutopilotDiscoveryTokens } from "./useAutopilotDiscoveryTokens";
    17→
    18→/**
    19→ * Token with enriched price data from NATS.
    20→ * Uses undefined for missing data to match AutopilotWatchedToken optionals.
    21→ */
    22→export interface AutopilotTokenWithPrices extends AutopilotWatchedToken {
    23→  priceUsd: number | undefined;
    24→  change1h: number | undefined;
    25→}
    26→
    27→/**
    28→ * Token lists with enriched price data.
    29→ */
    30→export interface AutopilotTokenListWithPrices {
    31→  watchlist: AutopilotTokenWithPrices[];
    32→  trending: AutopilotTokenWithPrices[];
    33→  whales: AutopilotTokenWithPrices[];
    34→}
    35→
    36→/**
    37→ * Hook to get autopilot token lists with live price data from NATS market data.
    38→ */
    39→export const useAutopilotTokensWithPrices =
    40→  (): AutopilotTokenListWithPrices => {
    41→    // Get token lists from Discovery API (whale/trending) + backend (watchlist)
    42→    const tokenList = useAutopilotDiscoveryTokens();
    43→
    44→    // Get market data map and SOL price for USD conversion
    45→    const marketDataMap = useGlobalStore(
    46→      useShallow(state => state.websocketMessages.market_data.data)
    47→    );
    48→
    49→    // SOL price is stored as string
    50→    const solPriceUsdStr = useGlobalStore(state => state.solanaPrice.usd);
    51→    const solPriceUsd = solPriceUsdStr ? parseFloat(solPriceUsdStr) : undefined;
    52→
    53→    // Enrich a single token with price data
    54→    const enrichToken = useMemo(() => {
    55→      return (token: AutopilotWatchedToken): AutopilotTokenWithPrices => {
    56→        const mintData = marketDataMap[token.mint];
    57→
    58→        if (!mintData || mintData.size === 0) {
    59→          return {
    60→            ...token,
    61→            priceUsd: undefined,
    62→            change1h: undefined,
    63→          };
    64→        }
    65→
    66→        // Get the latest market data
    67→        const latestMarketData = Array.from(mintData.values())[0];
    68→
    69→        if (!latestMarketData?.price_sol) {
    70→          return {
    71→            ...token,
    72→            priceUsd: undefined,
    73→            change1h: undefined,
    74→          };
    75→        }
    76→
    77→        // price_sol can be string or number from NATS, parse it
    78→        const rawPriceSol = latestMarketData.price_sol;
    79→        const priceSol =
    80→          typeof rawPriceSol === "string"
    81→            ? parseFloat(rawPriceSol)
    82→            : rawPriceSol;
    83→
    84→        if (isNaN(priceSol)) {
    85→          return {
    86→            ...token,
    87→            priceUsd: undefined,
    88→            change1h: undefined,
    89→          };
    90→        }
    91→
    92→        // Convert to USD
    93→        const priceUsd =
    94→          solPriceUsd && !isNaN(solPriceUsd)
    95→            ? priceSol * solPriceUsd
    96→            : undefined;
    97→
    98→        // Calculate 1h change from trading_stats_1h if available
    99→        let change1h: number | undefined = undefined;
   100→        const stats1h = latestMarketData.trading_stats_1h;
   101→        if (stats1h?.earliest_price_sol) {
   102→          const earliestPrice = parseFloat(String(stats1h.earliest_price_sol));
   103→          if (!isNaN(earliestPrice) && earliestPrice !== 0) {
   104→            change1h = ((priceSol - earliestPrice) / earliestPrice) * 100;
   105→          }
   106→        }
   107→
   108→        return {
   109→          ...token,
   110→          priceUsd,
   111→          change1h,
   112→        };
   113→      };
   114→    }, [marketDataMap, solPriceUsd]);
   115→
   116→    // Enrich all token lists
   117→    return useMemo(() => {
   118→      return {
   119→        watchlist: tokenList.watchlist.map(enrichToken),
   120→        trending: tokenList.trending.map(enrichToken),
   121→        whales: tokenList.whales.map(enrichToken),
   122→      };
   123→    }, [tokenList, enrichToken]);
   124→  };
   125→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
