     1→# Discover Workflow
     2→
     3→Map a repository or system and produce agent-centric documentation.
     4→
     5→## Inputs
     6→
     7→- **repo_path**: Path to the repository (required)
     8→- **system_name**: Name for this system (optional, inferred from repo)
     9→- **depth**: `quick` | `standard` | `thorough` (default: `standard`)
    10→
    11→## Process
    12→
    13→### Phase 1: Initial Survey
    14→
    15→```
    16→1. Check for existing documentation:
    17→   - ai.md (already exists? → read and potentially enhance)
    18→   - README.md
    19→   - CONTRIBUTING.md
    20→   - docs/ directory
    21→   - .claude/ directory (existing agent context?)
    22→
    23→2. Identify project type:
    24→   - Package manager files (package.json, Cargo.toml, pyproject.toml, etc.)
    25→   - Framework indicators
    26→   - Build system (Makefile, docker-compose, etc.)
    27→```
    28→
    29→### Phase 2: Structure Mapping
    30→
    31→```
    32→1. Directory structure analysis:
    33→   - What are the top-level directories?
    34→   - Where does source code live?
    35→   - Where are configs?
    36→   - Where are tests?
    37→
    38→2. Entry points:
    39→   - Main executables/binaries
    40→   - API entry points
    41→   - Service definitions
    42→
    43→3. Key files:
    44→   - Config files (*.toml, *.yaml, *.json)
    45→   - Environment files (.env.example)
    46→   - Schema definitions
    47→```
    48→
    49→### Phase 3: Capability Discovery
    50→
    51→```
    52→1. Data sources:
    53→   - Database connections (look in configs, connection strings)
    54→   - External API integrations
    55→   - Message queues / event streams
    56→   - File storage
    57→
    58→2. Interfaces exposed:
    59→   - REST endpoints (search for route definitions)
    60→   - WebSocket handlers
    61→   - CLI commands
    62→   - NATS/messaging topics
    63→
    64→3. Extension patterns:
    65→   - Plugin systems
    66→   - Hook points
    67→   - Configuration injection
    68→   - Middleware patterns
    69→```
    70→
    71→### Phase 4: Cross-System Context
    72→
    73→```
    74→1. Dependencies:
    75→   - What external services does this consume?
    76→   - What shared libraries/packages?
    77→   - What infrastructure requirements?
    78→
    79→2. Consumers:
    80→   - Who calls this system's APIs?
    81→   - What reads from its data stores?
    82→   - What subscribes to its events?
    83→
    84→3. Data flows:
    85→   - What comes in? From where?
    86→   - What goes out? To where?
    87→```
    88→
    89→### Phase 5: Synthesis
    90→
    91→```
    92→1. Compile findings into ai.md structure:
    93→   - Follow template from templates/AiMdTemplate.md
    94→   - Focus on capabilities, not just description
    95→   - Include concrete "Finding Code" section
    96→   - Link to existing detailed docs
    97→
    98→2. Quality check against template checklist:
    99→   - Does it answer understanding questions?
   100→   - Does it answer working questions?
   101→   - Does it answer extending questions?
   102→   - Is it agent-readable?
   103→
   104→3. Identify gaps:
   105→   - What couldn't be determined?
   106→   - What needs human input?
   107→   - What detailed docs are missing?
   108→```
   109→
   110→### Phase 6: Registration
   111→
   112→```
   113→1. Update central knowledge registry:
   114→   ~/Documents/Knowledge/registry.md
   115→
   116→2. Create/update system context file:
   117→   ~/Documents/Knowledge/systems/{system-name}/context.md
   118→
   119→3. Update cross-system maps if connections discovered:
   120→   ~/Documents/Knowledge/cross-system/
   121→```
   122→
   123→## Depth Levels
   124→
   125→### Quick
   126→- Phase 1 + basic Phase 2
   127→- Produces skeleton ai.md with gaps marked
   128→- ~2-3 minutes
   129→
   130→### Standard (default)
   131→- Phases 1-5
   132→- Produces complete draft ai.md
   133→- Registers in knowledge base
   134→- ~5-10 minutes
   135→
   136→### Thorough
   137→- All phases with deep exploration
   138→- Spawns research agents for external context
   139→- Validates all discovered interfaces
   140→- Produces comprehensive documentation
   141→- ~15-30 minutes
   142→
   143→## Output
   144→
   145→1. **ai.md file** - Written to repo root (or specified location)
   146→2. **Discovery report** - Summary of what was found and gaps
   147→3. **Registry update** - System added/updated in central knowledge
   148→
   149→## Example Invocation
   150→
   151→```
   152→User: "Map ~/Documents/BONKbot/github/web-api"
   153→
   154→-> Discover workflow executes
   155→-> Surveys existing docs (finds README, some scattered docs)
   156→-> Maps structure (TypeScript backend, Postgres, NATS)
   157→-> Discovers capabilities (user auth, wallet management, order execution)
   158→-> Identifies cross-system connections (consumes web-terminal data, serves frontend)
   159→-> Produces ai.md
   160→-> Registers in ~/Documents/Knowledge/
   161→
   162→Output:
   163→- Created ai.md at ~/Documents/BONKbot/github/web-api/ai.md
   164→- Registered "web-api" in knowledge registry
   165→- Found 3 cross-system connections (documented)
   166→- Gaps identified: API endpoint documentation incomplete
   167→```
   168→
   169→## Error Handling
   170→
   171→- **No repo found**: Ask user to confirm path
   172→- **Existing ai.md**: Ask whether to enhance or replace
   173→- **Can't determine project type**: Proceed with generic structure, flag for review
   174→- **External dependencies unclear**: Note as gap, suggest research follow-up
   175→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
