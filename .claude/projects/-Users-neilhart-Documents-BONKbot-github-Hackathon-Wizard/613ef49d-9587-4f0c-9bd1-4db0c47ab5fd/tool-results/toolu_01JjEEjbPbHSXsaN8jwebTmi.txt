     1→#!/usr/bin/env node
     2→/**
     3→ * CLI Interface
     4→ *
     5→ * Simple CLI for configuring and running the analysis autopilot.
     6→ */
     7→
     8→import { configStore } from './config/index.js';
     9→import type { TokenSource } from './config/types.js';
    10→import { templates, listTemplates, getTemplate, getTemplateSummary, RuleEngine } from './rules/index.js';
    11→import { localApi } from './api/index.js';
    12→import { paperTracker, createTrigger, createAutoSourceManager, magicExits, magicBuy, marketFilter, MarketFilter } from './trading/index.js';
    13→import { wsServer, type PositionData, type SignalData, type MarketStatusData, type StatsData, type WatchedToken, type TokenListData, type ConfigData, type AutopilotCommand, type StrategiesData, type StrategyInfo } from './websocket-server.js';
    14→
    15→// Wrapped SOL mint for market filter
    16→const SOL_MINT = 'So11111111111111111111111111111111111111112';
    17→
    18→const HELP = `
    19→Token Analysis Autopilot CLI
    20→
    21→Commands:
    22→  watch <mint> [symbol]  Add token to watchlist
    23→  unwatch <mint>         Remove token from watchlist
    24→  list                   List watchlist
    25→
    26→  sources                Show auto-source status (trending, whales)
    27→  sources on|off         Enable/disable auto-sources
    28→  sources trending on|off
    29→  sources whales on|off
    30→
    31→  templates              List available rule templates
    32→  use <template>         Add a template to active rules
    33→  remove <rule-id>       Remove a rule set
    34→  rules                  List active rules
    35→
    36→  config                 Show current config
    37→  mode <paper|live>      Set trigger mode
    38→  size <sol>             Set default position size
    39→
    40→  filter                 Show market filter status
    41→  filter on|off          Enable/disable market filter
    42→
    43→  analyze <mint>         Analyze a single token (with trigger)
    44→  run                    Start analysis loop
    45→
    46→  status                 Live portfolio overview with P&L
    47→  trades                 List all paper trades
    48→  stats                  Show trading stats
    49→  close <mint>           Close open position for mint
    50→  reset                  Clear all trading data
    51→
    52→  help                   Show this help
    53→`;
    54→
    55→async function main() {
    56→  const args = process.argv.slice(2);
    57→  const command = args[0]?.toLowerCase();
    58→
    59→  await configStore.load();
    60→  await paperTracker.load();
    61→
    62→  switch (command) {
    63→    case 'watch': {
    64→      const mint = args[1];
    65→      const symbol = args[2];
    66→      if (!mint) {
    67→        console.error('Usage: watch <mint> [symbol]');
    68→        process.exit(1);
    69→      }
    70→      configStore.addToWatchlist(mint, symbol);
    71→      await configStore.save();
    72→      console.log(`Added ${symbol || mint} to watchlist`);
    73→      break;
    74→    }
    75→
    76→    case 'unwatch': {
    77→      const mint = args[1];
    78→      if (!mint) {
    79→        console.error('Usage: unwatch <mint>');
    80→        process.exit(1);
    81→      }
    82→      if (configStore.removeFromWatchlist(mint)) {
    83→        await configStore.save();
    84→        console.log(`Removed ${mint} from watchlist`);
    85→      } else {
    86→        console.log('Token not found in watchlist');
    87→      }
    88→      break;
    89→    }
    90→
    91→    case 'list': {
    92→      const watchlist = configStore.getWatchlist();
    93→      if (watchlist.length === 0) {
    94→        console.log('Watchlist is empty');
    95→      } else {
    96→        console.log('\nWatchlist:');
    97→        for (const token of watchlist) {
    98→          console.log(`  ${token.symbol || 'Unknown'} - ${token.mint}`);
    99→        }
   100→      }
   101→      break;
   102→    }
   103→
   104→    case 'sources': {
   105→      const subCmd = args[1]?.toLowerCase();
   106→      const sourceConfig = configStore.getAutoSourceConfig();
   107→
   108→      if (!subCmd) {
   109→        // Show status
   110→        console.log('\nAuto-Sources:');
   111→        console.log(`  Enabled: ${sourceConfig.enabled ? 'Yes' : 'No'}`);
   112→        console.log(`  Trending: ${sourceConfig.trending ? 'On' : 'Off'} (limit: ${sourceConfig.trendingLimit})`);
   113→        console.log(`  Whales: ${sourceConfig.whales ? 'On' : 'Off'} (limit: ${sourceConfig.whalesLimit})`);
   114→        console.log(`  Refresh: every ${sourceConfig.refreshIntervalMs / 1000 / 60}m`);
   115→        console.log('\nSource indicators: [W]=watchlist [T]=trending [$]=whales');
   116→        break;
   117→      }
   118→
   119→      if (subCmd === 'on') {
   120→        configStore.setAutoSourceEnabled(true);
   121→        await configStore.save();
   122→        console.log('Auto-sources enabled');
   123→        break;
   124→      }
   125→
   126→      if (subCmd === 'off') {
   127→        configStore.setAutoSourceEnabled(false);
   128→        await configStore.save();
   129→        console.log('Auto-sources disabled');
   130→        break;
   131→      }
   132→
   133→      // Handle "sources trending on|off" or "sources whales on|off"
   134→      const sourceType = subCmd as 'trending' | 'whales';
   135→      const toggle = args[2]?.toLowerCase();
   136→
   137→      if ((sourceType === 'trending' || sourceType === 'whales') && (toggle === 'on' || toggle === 'off')) {
   138→        configStore.setSourceEnabled(sourceType, toggle === 'on');
   139→        await configStore.save();
   140→        console.log(`${sourceType} source ${toggle === 'on' ? 'enabled' : 'disabled'}`);
   141→        break;
   142→      }
   143→
   144→      console.error('Usage: sources [on|off] | sources <trending|whales> <on|off>');
   145→      break;
   146→    }
   147→
   148→    case 'templates': {
   149→      console.log('');
   150→      for (const id of listTemplates()) {
   151→        const template = templates[id];
   152→        console.log(`  ${id}:  ${getTemplateSummary(template)}`);
   153→      }
   154→      console.log('');
   155→      break;
   156→    }
   157→
   158→    case 'use': {
   159→      const templateId = args[1];
   160→      if (!templateId) {
   161→        console.error('Usage: use <template>');
   162→        console.error('Available:', listTemplates().join(', '));
   163→        process.exit(1);
   164→      }
   165→      const template = getTemplate(templateId);
   166→      if (!template) {
   167→        console.error(`Template not found: ${templateId}`);
   168→        console.error('Available:', listTemplates().join(', '));
   169→        process.exit(1);
   170→      }
   171→      configStore.addRuleSet(template);
   172→      await configStore.save();
   173→      console.log(`Added template: ${template.name}`);
   174→      break;
   175→    }
   176→
   177→    case 'remove': {
   178→      const ruleId = args[1];
   179→      if (!ruleId) {
   180→        console.error('Usage: remove <rule-id>');
   181→        process.exit(1);
   182→      }
   183→      if (configStore.removeRuleSet(ruleId)) {
   184→        await configStore.save();
   185→        console.log(`Removed rule set: ${ruleId}`);
   186→      } else {
   187→        console.log('Rule set not found');
   188→      }
   189→      break;
   190→    }
   191→
   192→    case 'rules': {
   193→      const ruleSets = configStore.getRuleSets();
   194→      if (ruleSets.length === 0) {
   195→        console.log('No active rule sets. Use "use <template>" to add one.');
   196→      } else {
   197→        console.log('\nActive Rule Sets:');
   198→        for (const ruleSet of ruleSets) {
   199→          console.log(`\n  ${ruleSet.name} (${ruleSet.id})`);
   200→          console.log(`    Mode: ${ruleSet.mode}`);
   201→          console.log(`    Rules:`);
   202→          for (const rule of ruleSet.rules) {
   203→            const status = rule.enabled ? 'Y' : 'X';
   204→            console.log(`      ${status} ${rule.name} (${rule.ruleType})`);
   205→          }
   206→        }
   207→      }
   208→      break;
   209→    }
   210→
   211→    case 'config': {
   212→      const config = configStore.get();
   213→      console.log('\nCurrent Configuration:');
   214→      console.log(`  Watchlist: ${config.watchlist.length} tokens`);
   215→      console.log(`  Rule Sets: ${config.ruleSets.length} active`);
   216→      console.log(`  Auto-Sources: ${config.autoSources.enabled ? 'On' : 'Off'} (T:${config.autoSources.trending ? 'Y' : 'N'} $:${config.autoSources.whales ? 'Y' : 'N'})`);
   217→      console.log(`  Trigger Mode: ${config.trigger.mode}`);
   218→      console.log(`  Trigger Enabled: ${config.trigger.enabled}`);
   219→      console.log(`  Position Size: ${config.trigger.defaultPositionSizeSol} SOL`);
   220→      console.log(`  Poll Interval: ${config.pollIntervalMs}ms`);
   221→      break;
   222→    }
   223→
   224→    case 'mode': {
   225→      const mode = args[1] as 'paper' | 'live';
   226→      if (!mode || !['paper', 'live'].includes(mode)) {
   227→        console.error('Usage: mode <paper|live>');
   228→        process.exit(1);
   229→      }
   230→      configStore.setTriggerMode(mode);
   231→      await configStore.save();
   232→      console.log(`Set trigger mode to: ${mode}`);
   233→      break;
   234→    }
   235→
   236→    case 'size': {
   237→      const size = parseFloat(args[1]);
   238→      if (isNaN(size) || size <= 0) {
   239→        console.error('Usage: size <sol_amount>');
   240→        process.exit(1);
   241→      }
   242→      configStore.setPositionSize(size);
   243→      await configStore.save();
   244→      console.log(`Set default position size to: ${size} SOL`);
   245→      break;
   246→    }
   247→
   248→    case 'filter': {
   249→      const subCmd = args[1]?.toLowerCase();
   250→      const filterConfig = configStore.getMarketFilterConfig();
   251→
   252→      if (!subCmd) {
   253→        // Show status
   254→        console.log('\nMarket Filter (SOL Dump Protection):');
   255→        console.log(`  Enabled: ${filterConfig.enabled ? 'Yes' : 'No'}`);
   256→        console.log(`  Timeframe: ${filterConfig.timeframeMinutes}m`);
   257→        console.log(`  Skip Entries: SOL < ${filterConfig.skipEntriesThreshold}%`);
   258→        console.log(`  Exit All: SOL < ${filterConfig.exitAllThreshold}%`);
   259→        console.log(`  Recovery: SOL >= ${filterConfig.recoveryThreshold}%`);
   260→        console.log(`\nState Machine:`);
   261→        console.log(`  NORMAL ──(${filterConfig.skipEntriesThreshold}%)──> CAUTION ──(${filterConfig.exitAllThreshold}%)──> DUMP`);
   262→        console.log(`     ^                                                │`);
   263→        console.log(`     └────────────────(>=${filterConfig.recoveryThreshold}%)────────────────────┘`);
   264→        break;
   265→      }
   266→
   267→      if (subCmd === 'on') {
   268→        configStore.setMarketFilterEnabled(true);
   269→        await configStore.save();
   270→        console.log('Market filter enabled');
   271→        break;
   272→      }
   273→
   274→      if (subCmd === 'off') {
   275→        configStore.setMarketFilterEnabled(false);
   276→        await configStore.save();
   277→        console.log('Market filter disabled');
   278→        break;
   279→      }
   280→
   281→      console.error('Usage: filter [on|off]');
   282→      break;
   283→    }
   284→
   285→    case 'analyze': {
   286→      const mint = args[1];
   287→      if (!mint) {
   288→        console.error('Usage: analyze <mint>');
   289→        process.exit(1);
   290→      }
   291→
   292→      const ruleSets = configStore.getRuleSets();
   293→      if (ruleSets.length === 0) {
   294→        console.error('No active rule sets. Use "use <template>" to add one.');
   295→        process.exit(1);
   296→      }
   297→
   298→      console.log(`\nAnalyzing ${mint}...`);
   299→
   300→      const engine = new RuleEngine({ api: localApi });
   301→      for (const ruleSet of ruleSets) {
   302→        engine.addRulesFromConfig(ruleSet.rules);
   303→      }
   304→
   305→      const signals = await engine.analyzeToken(mint);
   306→      const result = engine.aggregateSignals(signals);
   307→
   308→      console.log(`\nResult: ${result.action.toUpperCase()} (confidence: ${(result.confidence * 100).toFixed(0)}%)`);
   309→
   310→      if (signals.length > 0) {
   311→        console.log('\nSignals:');
   312→        for (const signal of signals) {
   313→          const emoji = signal.type === 'buy' ? '+' : signal.type === 'sell' ? '-' : '*';
   314→          console.log(`  ${emoji} ${signal.ruleName}: ${signal.reason}`);
   315→        }
   316→      } else {
   317→        console.log('\nNo signals triggered');
   318→      }
   319→
   320→      // Trigger trade if action is not hold
   321→      if (result.action !== 'hold') {
   322→        const trigger = createTrigger(configStore.getTriggerConfig());
   323→        const marketData = await localApi.getMarketData(mint);
   324→
   325→        const triggerResult = await trigger.trigger({
   326→          mint,
   327→          symbol: marketData.symbol,
   328→          action: result.action,
   329→          priceSol: marketData.price_sol,
   330→          priceUsd: marketData.price_usd,
   331→          ruleSetId: ruleSets[0].id,
   332→          signals: result.signals,
   333→          confidence: result.confidence,
   334→        });
   335→
   336→        if (!triggerResult.triggered) {
   337→          console.log(`\nTrade not triggered: ${triggerResult.reason}`);
   338→        }
   339→
   340→        await paperTracker.save();
   341→      }
   342→      break;
   343→    }
   344→
   345→    case 'run': {
   346→      const watchlist = configStore.getWatchlist();
   347→      const ruleSets = configStore.getRuleSets();
   348→
   349→      if (ruleSets.length === 0) {
   350→        console.error('No active rule sets. Use "use <template>" to add one.');
   351→        process.exit(1);
   352→      }
   353→
   354→      const config = configStore.get();
   355→      const trigger = createTrigger(config.trigger);
   356→      const autoSources = createAutoSourceManager(localApi, config.autoSources);
   357→
   358→      // Set up market filter with config
   359→      marketFilter.updateConfig(config.marketFilter);
   360→      marketFilter.setApi(localApi);
   361→
   362→      // Initial refresh of auto-sources
   363→      if (config.autoSources.enabled) {
   364→        console.log('Fetching auto-sources (trending, whales)...');
   365→        await autoSources.refresh();
   366→      }
   367→
   368→      // Helper to get source label for output
   369→      const sourceLabel = (source: TokenSource): string => {
   370→        switch (source) {
   371→          case 'watchlist': return 'W';
   372→          case 'trending': return 'T';
   373→          case 'whales': return '$';
   374→          default: return '?';
   375→        }
   376→      };
   377→
   378→      // Combine all token sources: watchlist + auto-sources + open positions
   379→      const getAllTokens = () => {
   380→        const tokens = new Map<string, { mint: string; symbol?: string; source: TokenSource }>();
   381→
   382→        // Manual watchlist (highest priority)
   383→        for (const t of watchlist) {
   384→          tokens.set(t.mint, { mint: t.mint, symbol: t.symbol, source: 'watchlist' });
   385→        }
   386→
   387→        // Auto-sources (if enabled)
   388→        if (config.autoSources.enabled) {
   389→          for (const t of autoSources.getSourcedTokens()) {
   390→            if (!tokens.has(t.mint)) {
   391→              tokens.set(t.mint, { mint: t.mint, symbol: t.symbol, source: t.source });
   392→            }
   393→          }
   394→        }
   395→
   396→        // Open positions (always include)
   397→        for (const trade of paperTracker.getOpenTrades()) {
   398→          if (!tokens.has(trade.mint)) {
   399→            // Determine source from auto-sources if available
   400→            const autoSource = autoSources.getSourceForMint(trade.mint);
   401→            tokens.set(trade.mint, {
   402→              mint: trade.mint,
   403→              symbol: trade.symbol,
   404→              source: autoSource || 'watchlist',
   405→            });
   406→          }
   407→        }
   408→
   409→        return Array.from(tokens.values());
   410→      };
   411→
   412→      const allTokens = getAllTokens();
   413→      const autoSourceCounts = autoSources.getCounts();
   414→
   415→      if (allTokens.length === 0) {
   416→        console.error('Nothing to watch. Add tokens with "watch <mint>", enable auto-sources, or have open trades.');
   417→        process.exit(1);
   418→      }
   419→
   420→      const openCount = paperTracker.getOpenTrades().length;
   421→      const mfStatus = config.marketFilter.enabled ? 'On' : 'Off';
   422→
   423→      // Start WebSocket server for frontend
   424→      wsServer.start(8765);
   425→
   426→      // Helper to get current config for broadcasting
   427→      const getCurrentConfig = (): ConfigData => ({
   428→        autoSourcesEnabled: configStore.getAutoSourceConfig().enabled,
   429→        trendingEnabled: configStore.getAutoSourceConfig().trending,
   430→        whalesEnabled: configStore.getAutoSourceConfig().whales,
   431→        marketFilterEnabled: configStore.getMarketFilterConfig().enabled,
   432→        mode: configStore.getTriggerConfig().mode,
   433→        positionSizeSol: configStore.getTriggerConfig().defaultPositionSizeSol,
   434→        pollIntervalMs: configStore.get().pollIntervalMs,
   435→      });
   436→
   437→      // Helper to get strategies data for broadcasting
   438→      const getStrategiesData = (): StrategiesData => {
   439→        const activeRuleSets = configStore.getRuleSets();
   440→        const activeIds = new Set(activeRuleSets.map(r => r.id));
   441→
   442→        const available: StrategyInfo[] = listTemplates().map(id => {
   443→          const t = templates[id];
   444→          return {
   445→            id: t.id,
   446→            name: t.name,
   447→            description: t.description,
   448→            mode: t.mode,
   449→            ruleCount: t.rules.length,
   450→            summary: getTemplateSummary(t),
   451→          };
   452→        });
   453→
   454→        return {
   455→          available,
   456→          active: Array.from(activeIds),
   457→        };
   458→      };
   459→
   460→      // Handle commands from frontend
   461→      wsServer.onCommand(async (cmd: AutopilotCommand) => {
   462→        switch (cmd.command) {
   463→          case 'toggle_sources':
   464→            configStore.setAutoSourceEnabled(cmd.enabled);
   465→            await configStore.save();
   466→            console.log(`[WS] Auto-sources ${cmd.enabled ? 'enabled' : 'disabled'}`);
   467→            break;
   468→          case 'toggle_trending':
   469→            configStore.setSourceEnabled('trending', cmd.enabled);
   470→            await configStore.save();
   471→            console.log(`[WS] Trending source ${cmd.enabled ? 'enabled' : 'disabled'}`);
   472→            break;
   473→          case 'toggle_whales':
   474→            configStore.setSourceEnabled('whales', cmd.enabled);
   475→            await configStore.save();
   476→            console.log(`[WS] Whales source ${cmd.enabled ? 'enabled' : 'disabled'}`);
   477→            break;
   478→          case 'toggle_filter':
   479→            configStore.setMarketFilterEnabled(cmd.enabled);
   480→            await configStore.save();
   481→            console.log(`[WS] Market filter ${cmd.enabled ? 'enabled' : 'disabled'}`);
   482→            marketFilter.updateConfig(configStore.getMarketFilterConfig());
   483→            break;
   484→          case 'set_mode':
   485→            configStore.setTriggerMode(cmd.mode);
   486→            await configStore.save();
   487→            console.log(`[WS] Mode set to ${cmd.mode}`);
   488→            break;
   489→          case 'set_position_size':
   490→            configStore.setPositionSize(cmd.sizeSol);
   491→            await configStore.save();
   492→            console.log(`[WS] Position size set to ${cmd.sizeSol} SOL`);
   493→            break;
   494→          case 'refresh_sources':
   495→            console.log('[WS] Refreshing auto-sources...');
   496→            await autoSources.refresh();
   497→            break;
   498→          case 'get_config':
   499→            // Just broadcast current config
   500→            break;
   501→          case 'get_strategies':
   502→            // Just broadcast strategies
   503→            break;
   504→          case 'toggle_strategy': {
   505→            const strategyId = cmd.strategyId;
   506→            const enable = cmd.enabled;
   507→            if (enable) {
   508→              // Add strategy from templates
   509→              const template = getTemplate(strategyId);
   510→              if (template) {
   511→                configStore.addRuleSet(template);
   512→                await configStore.save();
   513→                // Reload rules in engine
   514→                engine.clearRules();
   515→                for (const ruleSet of configStore.getRuleSets()) {
   516→                  engine.addRulesFromConfig(ruleSet.rules);
   517→                }
   518→                console.log(`[WS] Strategy enabled: ${template.name}`);
   519→              }
   520→            } else {
   521→              // Remove strategy
   522→              if (configStore.removeRuleSet(strategyId)) {
   523→                await configStore.save();
   524→                // Reload rules in engine
   525→                engine.clearRules();
   526→                for (const ruleSet of configStore.getRuleSets()) {
   527→                  engine.addRulesFromConfig(ruleSet.rules);
   528→                }
   529→                console.log(`[WS] Strategy disabled: ${strategyId}`);
   530→              }
   531→            }
   532→            break;
   533→          }
   534→        }
   535→        // Always broadcast updated config and strategies after any command
   536→        wsServer.broadcastConfig(getCurrentConfig());
   537→        wsServer.broadcastStrategies(getStrategiesData());
   538→      });
   539→
   540→      // Send initial state to newly connected clients
   541→      wsServer.onConnect(() => {
   542→        wsServer.broadcastConfig(getCurrentConfig());
   543→        const strategiesData = getStrategiesData();
   544→        console.log(`[WS] Sending initial state: ${strategiesData.available.length} strategies available, ${strategiesData.active.length} active`);
   545→        wsServer.broadcastStrategies(strategiesData);
   546→      });
   547→
   548→      console.log('Starting analysis loop... (Ctrl+C to stop)');
   549→      console.log(`  Watchlist: ${watchlist.length} | Trending: ${autoSourceCounts.trending} | Whales: ${autoSourceCounts.whales}`);
   550→      console.log(`  Open trades: ${openCount} | Rules: ${ruleSets.length} sets | Mode: ${config.trigger.mode}`);
   551→      console.log(`  Market Filter: ${mfStatus} (skip@${config.marketFilter.skipEntriesThreshold}% exit@${config.marketFilter.exitAllThreshold}%)`);
   552→      console.log(`  Scan interval: ${config.pollIntervalMs}ms | Source refresh: ${config.autoSources.refreshIntervalMs / 1000}s`);
   553→      console.log(`  WebSocket: ws://localhost:8765\n`);
   554→
   555→      const engine = new RuleEngine({ api: localApi });
   556→      for (const ruleSet of ruleSets) {
   557→        engine.addRulesFromConfig(ruleSet.rules);
   558→      }
   559→
   560→      let scanCount = 0;
   561→      const runLoop = async () => {
   562→        scanCount++;
   563→        const time = new Date().toLocaleTimeString('en-US', { hour12: false });
   564→
   565→        // Refresh auto-sources if needed (every 15m by default)
   566→        await autoSources.refreshIfNeeded();
   567→
   568→        // Get fresh token list
   569→        const tokens = getAllTokens();
   570→        const openTrades = paperTracker.getOpenTrades();
   571→        const openMints = new Set(openTrades.map(t => t.mint));
   572→
   573→        // Batch fetch all market data upfront (including SOL for market filter)
   574→        const allMints = [...tokens.map(t => t.mint)];
   575→        if (!allMints.includes(SOL_MINT)) {
   576→          allMints.push(SOL_MINT);
   577→        }
   578→        const marketDataCache = await localApi.getMarketDataBatch(allMints);
   579→
   580→        // Check market filter (SOL dump protection)
   581→        // Try direct SOL data first, fallback to deriving from token prices
   582→        const solData = marketDataCache.get(SOL_MINT);
   583→        const marketFilterResult = marketFilter.check(solData, undefined, marketDataCache);
   584→
   585→        // Fetch 1m candles for open positions (needed for Williams TSL)
   586→        // Only fetch for positions we have open - this enables trailing stop
   587→        const candleDataMap = new Map<string, import('./api/types.js').OHLCV[]>();
   588→        for (const trade of openTrades) {
   589→          try {
   590→            // Fetch last 50 1m candles (enough for 3/3 fractal detection)
   591→            const candles = await localApi.getOHLCV(trade.mint, '1m', { countback: 50 });
   592→            if (candles.length > 0) {
   593→              candleDataMap.set(trade.mint, candles);
   594→            }
   595→          } catch {
   596→            // OHLCV not available for this token - TSL won't work but TP/SL will
   597→          }
   598→        }
   599→
   600→        // Check magic exits (TP at resistance, SL at support break, TSL at fractal)
   601→        // Magic exits still run even in CAUTION mode (structure-based exits are always valid)
   602→        const magicExitResults = await magicExits.executeExits(marketDataCache, true, candleDataMap);
   603→
   604→        // Handle market dump - exit all positions
   605→        let marketDumpExits: typeof magicExitResults = [];
   606→        if (marketFilterResult.exitAll) {
   607→          marketDumpExits = await marketFilter.executeExitAll(marketDataCache, true);
   608→        }
   609→
   610→        // Magic buy - auto-enter at support levels (only if market filter allows entries)
   611→        // Uses same OHLCV data as TSL for SFP detection
   612→        const magicBuyResults = !marketFilterResult.blockEntries
   613→          ? await magicBuy.executeEntries(marketDataCache, candleDataMap, true)
   614→          : { entries: [], skipped: [] };
   615→
   616→        const scanResults: string[] = [];
   617→        const tradeResults: string[] = [];
   618→        const magicResults: string[] = [];
   619→        const magicEntryResults: string[] = [];
   620→        const dumpExitResults: string[] = [];
   621→
   622→        // Record market dump exits
   623→        for (const closed of marketDumpExits) {
   624→          const pnlSign = (closed.pnlPercent ?? 0) >= 0 ? '+' : '';
   625→          const color = (closed.pnlPercent ?? 0) >= 0 ? '\x1b[32m' : '\x1b[31m';
   626→          const reset = '\x1b[0m';
   627→          dumpExitResults.push(`${closed.symbol}:${color}${pnlSign}${closed.pnlPercent?.toFixed(1)}%${reset}`);
   628→        }
   629→
   630→        // Record magic exits
   631→        for (const closed of magicExitResults) {
   632→          const pnlSign = (closed.pnlPercent ?? 0) >= 0 ? '+' : '';
   633→          const color = (closed.pnlPercent ?? 0) >= 0 ? '\x1b[32m' : '\x1b[31m';
   634→          const reset = '\x1b[0m';
   635→          magicResults.push(`${closed.symbol}:${color}${pnlSign}${closed.pnlPercent?.toFixed(1)}%${reset}`);
   636→        }
   637→
   638→        // Record magic buy entries
   639→        for (const { trade, entry } of magicBuyResults.entries) {
   640→          const entryLabel = entry.entryType?.toUpperCase() || 'BUY';
   641→          const color = '\x1b[36m'; // Cyan for new entries
   642→          const reset = '\x1b[0m';
   643→          magicEntryResults.push(`${color}${trade.symbol}[${entryLabel}]${reset}`);
   644→        }
   645→
   646→        // Process all tokens (fast path - no additional API calls)
   647→        for (const token of tokens) {
   648→          const isOpenTrade = openMints.has(token.mint);
   649→
   650→          // Get cached market data first
   651→          const marketData = marketDataCache.get(token.mint);
   652→          if (!marketData) continue; // Skip tokens without data
   653→
   654→          const sym = token.symbol || marketData.symbol || token.mint.slice(0, 6);
   655→          const src = sourceLabel(token.source);
   656→
   657→          try {
   658→            // Use fast path - analyze with pre-fetched market data (no API calls)
   659→            const signals = engine.analyzeWithMarketData(marketData);
   660→            const result = engine.aggregateSignals(signals);
   661→
   662→            // If this is an open trade, show P&L
   663→            if (isOpenTrade) {
   664→              const trade = openTrades.find(t => t.mint === token.mint)!;
   665→              const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
   666→              const sign = pnl.pnlPercent >= 0 ? '+' : '';
   667→              const size = trade.positionSizeSol.toFixed(2);
   668→              const color = pnl.pnlPercent >= 0 ? '\x1b[32m' : '\x1b[31m';
   669→              const reset = '\x1b[0m';
   670→              tradeResults.push(`[${src}]${sym} (${size}) ${color}${sign}${pnl.pnlPercent.toFixed(1)}%${reset}`);
   671→
   672→              // Check for exit signals
   673→              if (result.action !== 'hold') {
   674→                const triggerResult = await trigger.trigger({
   675→                  mint: token.mint,
   676→                  symbol: trade.symbol,
   677→                  action: result.action,
   678→                  priceSol: marketData.price_sol,
   679→                  priceUsd: marketData.price_usd,
   680→                  ruleSetId: ruleSets[0].id,
   681→                  signals: result.signals,
   682→                  confidence: result.confidence,
   683→                  quiet: true,
   684→                });
   685→                if (triggerResult.triggered) {
   686→                  tradeResults[tradeResults.length - 1] += ' EXIT';
   687→                }
   688→                await paperTracker.save();
   689→              }
   690→            } else {
   691→              // Scan result (not an open trade)
   692→              if (result.action !== 'hold') {
   693→                // Skip new entries if market filter is blocking
   694→                if (marketFilterResult.blockEntries && result.action === 'buy') {
   695→                  // Don't open new long positions during market stress
   696→                  continue;
   697→                }
   698→
   699→                const conf = (result.confidence * 100).toFixed(0);
   700→                const color = result.action === 'buy' ? '\x1b[32m' : '\x1b[31m';
   701→                const reset = '\x1b[0m';
   702→
   703→                const triggerResult = await trigger.trigger({
   704→                  mint: token.mint,
   705→                  symbol: marketData.symbol || token.symbol || 'UNKNOWN',
   706→                  action: result.action,
   707→                  priceSol: marketData.price_sol,
   708→                  priceUsd: marketData.price_usd,
   709→                  ruleSetId: ruleSets[0].id,
   710→                  signals: result.signals,
   711→                  confidence: result.confidence,
   712→                  quiet: true,
   713→                });
   714→
   715→                // Only show signals that actually triggered a trade
   716→                if (triggerResult.triggered) {
   717→                  scanResults.push(`[${src}]${sym}:${color}${result.action.toUpperCase()}(${conf}%)${reset}`);
   718→                }
   719→                await paperTracker.save();
   720→              }
   721→            }
   722→          } catch {
   723→            if (isOpenTrade) {
   724→              tradeResults.push(`[${src}]${sym}:ERR`);
   725→            } else {
   726→              scanResults.push(`[${src}]${sym}:ERR`);
   727→            }
   728→          }
   729→        }
   730→
   731→        // Output - compact single line
   732→        let line = `[${time}] #${scanCount}`;
   733→
   734→        // Market filter status (always show if not NORMAL)
   735→        if (marketFilterResult.state !== 'NORMAL') {
   736→          const mfColor = marketFilterResult.state === 'DUMP' ? '\x1b[31m' : '\x1b[33m';
   737→          const reset = '\x1b[0m';
   738→          const changeStr = marketFilterResult.priceChangePercent.toFixed(1);
   739→          line += `  |  ${mfColor}SOL ${changeStr}% [${marketFilterResult.state}]${reset}`;
   740→        }
   741→
   742→        // Market dump exits
   743→        if (dumpExitResults.length > 0) {
   744→          line += `  |  DumpExit: ${dumpExitResults.join(' ')}`;
   745→        }
   746→
   747→        // Magic exits
   748→        if (magicResults.length > 0) {
   749→          line += `  |  MagicExit: ${magicResults.join(' ')}`;
   750→        }
   751→
   752→        // Magic buy entries
   753→        if (magicEntryResults.length > 0) {
   754→          line += `  |  MagicBuy: ${magicEntryResults.join(' ')}`;
   755→        }
   756→
   757→        // New trades (from rule signals)
   758→        if (scanResults.length > 0) {
   759→          line += `  |  Signal: ${scanResults.join(' ')}`;
   760→        }
   761→
   762→        // Open positions
   763→        if (tradeResults.length > 0) {
   764→          line += `  |  Open: ${tradeResults.join(' ')}`;
   765→        }
   766→
   767→        // No activity indicator
   768→        if (scanResults.length === 0 && tradeResults.length === 0 && magicResults.length === 0 && magicEntryResults.length === 0 && dumpExitResults.length === 0) {
   769→          if (marketFilterResult.state === 'NORMAL') {
   770→            line += `  |  (${tokens.length} tokens)  |  No signals`;
   771→          }
   772→        }
   773→
   774→        console.log(line);
   775→
   776→        // === WebSocket Broadcasts ===
   777→
   778→        // Broadcast scan tick
   779→        wsServer.broadcastScanTick({
   780→          timestamp: Date.now(),
   781→          scanNumber: scanCount,
   782→          tokenCount: tokens.length,
   783→          openPositions: openTrades.length,
   784→        });
   785→
   786→        // Broadcast token list grouped by source
   787→        const tokenListData: TokenListData = {
   788→          watchlist: [],
   789→          trending: [],
   790→          whales: [],
   791→        };
   792→        for (const token of tokens) {
   793→          const marketData = marketDataCache.get(token.mint);
   794→          const watchedToken: WatchedToken = {
   795→            mint: token.mint,
   796→            symbol: token.symbol || marketData?.symbol || token.mint.slice(0, 6),
   797→            source: token.source,
   798→            priceSol: marketData?.price_sol,
   799→            priceUsd: marketData?.price_usd,
   800→            change1h: marketData?.price_change_1h,
   801→            change24h: marketData?.price_change_24h,
   802→            volume24h: marketData?.volume_24h,
   803→            mcap: marketData?.mcap,
   804→            hasPosition: openMints.has(token.mint),
   805→          };
   806→          if (token.source === 'watchlist') {
   807→            tokenListData.watchlist.push(watchedToken);
   808→          } else if (token.source === 'trending') {
   809→            tokenListData.trending.push(watchedToken);
   810→          } else if (token.source === 'whales') {
   811→            tokenListData.whales.push(watchedToken);
   812→          }
   813→        }
   814→        wsServer.broadcastTokenList(tokenListData);
   815→
   816→        // Broadcast market status
   817→        wsServer.broadcastMarketStatus({
   818→          state: marketFilterResult.state as 'NORMAL' | 'CAUTION' | 'DUMP',
   819→          solPriceChangePercent: marketFilterResult.priceChangePercent,
   820→          blockEntries: marketFilterResult.blockEntries,
   821→          exitAll: marketFilterResult.exitAll,
   822→        });
   823→
   824→        // Broadcast positions with live P&L
   825→        const positionData: PositionData[] = [];
   826→        if (openTrades.length > 0) {
   827→          console.log(`[WS] Open trades: ${openTrades.length}, mints: ${openTrades.map(t => t.symbol).join(', ')}`);
   828→        }
   829→        for (const trade of openTrades) {
   830→          const marketData = marketDataCache.get(trade.mint);
   831→          if (marketData) {
   832→            const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
   833→            positionData.push({
   834→              mint: trade.mint,
   835→              symbol: trade.symbol,
   836→              action: trade.action,
   837→              entryPriceSol: trade.entryPriceSol,
   838→              currentPriceSol: marketData.price_sol,
   839→              positionSizeSol: trade.positionSizeSol,
   840→              pnlPercent: pnl.pnlPercent,
   841→              pnlSol: pnl.pnlSol,
   842→              entryTime: trade.timestamp,
   843→            });
   844→          } else {
   845→            console.log(`[WS] No market data for ${trade.symbol} (${trade.mint.slice(0, 8)}...)`);
   846→          }
   847→        }
   848→        console.log(`[WS] Broadcasting ${positionData.length} positions`);
   849→        wsServer.broadcastPositions(positionData);
   850→
   851→        // Broadcast signals for magic exits
   852→        for (const closed of magicExitResults) {
   853→          wsServer.broadcastSignal({
   854→            timestamp: Date.now(),
   855→            mint: closed.mint,
   856→            symbol: closed.symbol,
   857→            signalType: 'magic_exit',
   858→            action: 'close',
   859→            reason: closed.reason || 'Magic exit triggered',
   860→            pnlPercent: closed.pnlPercent,
   861→          });
   862→        }
   863→
   864→        // Broadcast signals for dump exits
   865→        for (const closed of marketDumpExits) {
   866→          wsServer.broadcastSignal({
   867→            timestamp: Date.now(),
   868→            mint: closed.mint,
   869→            symbol: closed.symbol,
   870→            signalType: 'dump_exit',
   871→            action: 'close',
   872→            reason: 'Market dump protection',
   873→            pnlPercent: closed.pnlPercent,
   874→          });
   875→        }
   876→
   877→        // Broadcast signals for magic buy entries
   878→        for (const { trade, entry } of magicBuyResults.entries) {
   879→          wsServer.broadcastSignal({
   880→            timestamp: Date.now(),
   881→            mint: trade.mint,
   882→            symbol: trade.symbol,
   883→            signalType: 'magic_buy',
   884→            action: 'buy',
   885→            reason: entry.reason,
   886→            entryType: entry.entryType || undefined,
   887→          });
   888→        }
   889→
   890→        // Broadcast updated stats
   891→        const stats = paperTracker.getStats();
   892→        wsServer.broadcastStats({
   893→          totalTrades: stats.totalTrades,
   894→          openTrades: stats.openTrades,
   895→          closedTrades: stats.closedTrades,
   896→          wins: stats.wins,
   897→          losses: stats.losses,
   898→          winRate: stats.winRate,
   899→          totalPnlSol: stats.totalPnlSol,
   900→          totalPnlUsd: stats.totalPnlUsd,
   901→          avgPnlPercent: stats.avgPnlPercent,
   902→        });
   903→      };
   904→
   905→      // Run immediately, then on interval
   906→      await runLoop();
   907→      setInterval(runLoop, config.pollIntervalMs);
   908→      break;
   909→    }
   910→
   911→    case 'status': {
   912→      const openTrades = paperTracker.getOpenTrades();
   913→      const stats = paperTracker.getStats();
   914→      const ruleSets = configStore.getRuleSets();
   915→      const watchlist = configStore.getWatchlist();
   916→
   917→      console.log('\n=== PORTFOLIO STATUS ===\n');
   918→
   919→      // Open positions with live P&L
   920→      if (openTrades.length === 0) {
   921→        console.log('Open Positions: none\n');
   922→      } else {
   923→        console.log('Open Positions:');
   924→        let totalUnrealizedSol = 0;
   925→        let totalUnrealizedUsd = 0;
   926→        let totalExposure = 0;
   927→
   928→        for (const trade of openTrades) {
   929→          try {
   930→            const marketData = await localApi.getMarketData(trade.mint);
   931→            const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
   932→            const sign = pnl.pnlPercent >= 0 ? '+' : '';
   933→            totalUnrealizedSol += pnl.pnlSol;
   934→            totalUnrealizedUsd += pnl.pnlUsd;
   935→            totalExposure += trade.positionSizeSol;
   936→
   937→            console.log(`  ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${pnl.pnlPercent.toFixed(2)}%  (${sign}${pnl.pnlSol.toFixed(4)} SOL)`);
   938→            console.log(`    Entry: ${trade.entryPriceSol} -> Now: ${marketData.price_sol} SOL`);
   939→          } catch {
   940→            console.log(`  ${trade.action.toUpperCase()} ${trade.symbol}  (price fetch failed)`);
   941→          }
   942→        }
   943→
   944→        const unrealizedSign = totalUnrealizedSol >= 0 ? '+' : '';
   945→        console.log(`\n  Exposure: ${totalExposure.toFixed(4)} SOL`);
   946→        console.log(`  Unrealized: ${unrealizedSign}${totalUnrealizedSol.toFixed(4)} SOL ($${totalUnrealizedUsd.toFixed(2)})\n`);
   947→      }
   948→
   949→      // Realized P&L
   950→      console.log('Realized P&L:');
   951→      const realizedSign = stats.totalPnlSol >= 0 ? '+' : '';
   952→      console.log(`  ${stats.closedTrades} trades | ${stats.wins}W/${stats.losses}L | ${(stats.winRate * 100).toFixed(0)}% win`);
   953→      console.log(`  Total: ${realizedSign}${stats.totalPnlSol.toFixed(4)} SOL ($${stats.totalPnlUsd.toFixed(2)})\n`);
   954→
   955→      // Active config
   956→      console.log('Config:');
   957→      console.log(`  Watching: ${watchlist.length} tokens | Rules: ${ruleSets.length} sets`);
   958→      console.log(`  Mode: ${configStore.getTriggerConfig().mode}\n`);
   959→
   960→      break;
   961→    }
   962→
   963→    case 'trades': {
   964→      const trades = paperTracker.getAllTrades();
   965→      if (trades.length === 0) {
   966→        console.log('No trades recorded');
   967→      } else {
   968→        console.log('\nPaper Trades:');
   969→        for (const trade of trades) {
   970→          if (trade.status === 'open') {
   971→            try {
   972→              const marketData = await localApi.getMarketData(trade.mint);
   973→              const pnl = paperTracker.calcUnrealizedPnl(trade, marketData.price_sol, marketData.price_usd);
   974→              const sign = pnl.pnlPercent >= 0 ? '+' : '';
   975→              console.log(`  [OPEN] ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${pnl.pnlPercent.toFixed(2)}%`);
   976→              console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
   977→            } catch {
   978→              console.log(`  [OPEN] ${trade.action.toUpperCase()} ${trade.symbol}`);
   979→              console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
   980→            }
   981→          } else {
   982→            const sign = (trade.pnlPercent ?? 0) >= 0 ? '+' : '';
   983→            console.log(`  [CLOSED] ${trade.action.toUpperCase()} ${trade.symbol}  ${sign}${trade.pnlPercent?.toFixed(2)}%`);
   984→            console.log(`    Entry: ${trade.entryPriceSol} SOL | Size: ${trade.positionSizeSol.toFixed(4)} SOL`);
   985→          }
   986→        }
   987→      }
   988→      break;
   989→    }
   990→
   991→    case 'stats': {
   992→      const stats = paperTracker.getStats();
   993→      console.log('\nTrading Statistics:');
   994→      console.log(`  Total Trades: ${stats.totalTrades}`);
   995→      console.log(`  Open: ${stats.openTrades} | Closed: ${stats.closedTrades}`);
   996→      console.log(`  Wins: ${stats.wins} | Losses: ${stats.losses}`);
   997→      console.log(`  Win Rate: ${(stats.winRate * 100).toFixed(1)}%`);
   998→      console.log(`  Total P&L: ${stats.totalPnlSol.toFixed(4)} SOL ($${stats.totalPnlUsd.toFixed(2)})`);
   999→      console.log(`  Avg P&L: ${stats.avgPnlPercent.toFixed(2)}%`);
  1000→      if (stats.bestTrade) {
  1001→        console.log(`  Best: ${stats.bestTrade.symbol} +${stats.bestTrade.pnlPercent?.toFixed(2)}%`);
  1002→      }
  1003→      if (stats.worstTrade) {
  1004→        console.log(`  Worst: ${stats.worstTrade.symbol} ${stats.worstTrade.pnlPercent?.toFixed(2)}%`);
  1005→      }
  1006→      break;
  1007→    }
  1008→
  1009→    case 'close': {
  1010→      const mint = args[1];
  1011→      if (!mint) {
  1012→        console.error('Usage: close <mint>');
  1013→        process.exit(1);
  1014→      }
  1015→
  1016→      const openTrade = paperTracker.getOpenTradeForMint(mint);
  1017→      if (!openTrade) {
  1018→        console.log('No open position for this mint');
  1019→        break;
  1020→      }
  1021→
  1022→      const marketData = await localApi.getMarketData(mint);
  1023→      const trigger = createTrigger(configStore.getTriggerConfig());
  1024→      await trigger.closePosition(mint, marketData.price_sol, marketData.price_usd);
  1025→      await paperTracker.save();
  1026→      break;
  1027→    }
  1028→
  1029→    case 'reset': {
  1030→      paperTracker.clearAll();
  1031→      await paperTracker.save();
  1032→      console.log('All trading data cleared');
  1033→      break;
  1034→    }
  1035→
  1036→    case 'help':
  1037→    default:
  1038→      console.log(HELP);
  1039→  }
  1040→}
  1041→
  1042→main().catch(console.error);
  1043→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
