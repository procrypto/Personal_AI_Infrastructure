     1→/**
     2→ * Rotations Rule
     3→ *
     4→ * Implements the Rotations v1.5.2 algorithm for detecting market structure
     5→ * via candlestick rotations. Tracks support/resistance levels dynamically.
     6→ *
     7→ * Reference: tradingview/Rotations1.5.2.pine.js
     8→ *
     9→ * Core Logic:
    10→ * - Upward Rotation (+1): close > rotationHigh AND close > high[1]
    11→ * - Downward Rotation (-1): close < rotationLow AND close < low[1]
    12→ * - Invalidation (0): crosses opposite level without new rotation
    13→ */
    14→
    15→import type { OHLCV } from '../api/types.js';
    16→import type { Rule, Signal, AnalysisContext, RotationsRuleConfig } from './types.js';
    17→
    18→// ============================================================================
    19→// Types
    20→// ============================================================================
    21→
    22→export type RotationState = -1 | 0 | 1; // -1 = down, 0 = invalidated, 1 = up
    23→
    24→export interface RotationLevels {
    25→  rotationHigh: number;
    26→  rotationLow: number;
    27→  state: RotationState;
    28→  barIndex: number; // When current rotation started
    29→}
    30→
    31→export interface RotationAnalysis {
    32→  current: RotationLevels;
    33→  htf?: RotationLevels; // Higher timeframe levels (optional)
    34→  signals: {
    35→    newUpRotation: boolean;
    36→    newDownRotation: boolean;
    37→    invalidation: boolean;
    38→    atSupport: boolean; // Price near rotationLow
    39→    atResistance: boolean; // Price near rotationHigh
    40→    falseBreakoutHigh: boolean; // Wick above, close below (orange)
    41→    falseBreakoutLow: boolean; // Wick below, close above (orange)
    42→    htfAligned: boolean; // Current TF matches HTF direction
    43→  };
    44→}
    45→
    46→// ============================================================================
    47→// Rotation Calculator
    48→// ============================================================================
    49→
    50→/**
    51→ * Calculate rotation state from OHLCV data.
    52→ * Processes bars sequentially to build rotation levels.
    53→ */
    54→export function calculateRotations(ohlcv: OHLCV[]): RotationLevels | null {
    55→  if (ohlcv.length < 2) return null;
    56→
    57→  // Sort by timestamp ascending (oldest first)
    58→  const bars = [...ohlcv].sort((a, b) => a.timestamp - b.timestamp);
    59→
    60→  // Initialize with first bar
    61→  let rotationHigh = bars[0].high;
    62→  let rotationLow = bars[0].low;
    63→  let state: RotationState = 0;
    64→  let rotationStartIndex = 0;
    65→
    66→  // Process each bar
    67→  for (let i = 1; i < bars.length; i++) {
    68→    const bar = bars[i];
    69→    const prevBar = bars[i - 1];
    70→
    71→    let newState: RotationState = state;
    72→
    73→    // Check for new upward rotation
    74→    if (bar.close > rotationHigh && bar.close > prevBar.high) {
    75→      newState = 1;
    76→      rotationHigh = bar.high;
    77→      rotationLow = bar.low;
    78→      rotationStartIndex = i;
    79→    }
    80→    // Check for new downward rotation
    81→    else if (bar.close < rotationLow && bar.close < prevBar.low) {
    82→      newState = -1;
    83→      rotationHigh = bar.high;
    84→      rotationLow = bar.low;
    85→      rotationStartIndex = i;
    86→    }
    87→    // Check for invalidation (crosses opposite level without new rotation)
    88→    else if (
    89→      (state > 0 && bar.close < rotationLow) ||
    90→      (state < 0 && bar.close > rotationHigh)
    91→    ) {
    92→      newState = 0;
    93→    }
    94→
    95→    state = newState;
    96→  }
    97→
    98→  return {
    99→    rotationHigh,
   100→    rotationLow,
   101→    state,
   102→    barIndex: rotationStartIndex,
   103→  };
   104→}
   105→
   106→/**
   107→ * Analyze current price against rotation levels.
   108→ * Returns detailed analysis including signals.
   109→ */
   110→export function analyzeRotations(
   111→  currentPrice: number,
   112→  currentHigh: number,
   113→  currentLow: number,
   114→  levels: RotationLevels,
   115→  htfLevels?: RotationLevels,
   116→  levelBuffer: number = 0.5
   117→): RotationAnalysis {
   118→  const bufferMultiplier = 1 + levelBuffer / 100;
   119→  const bufferDivisor = 1 - levelBuffer / 100;
   120→
   121→  // Detect if price is near levels
   122→  const atSupport =
   123→    currentLow <= levels.rotationLow * bufferMultiplier &&
   124→    currentPrice >= levels.rotationLow * bufferDivisor;
   125→
   126→  const atResistance =
   127→    currentHigh >= levels.rotationHigh * bufferDivisor &&
   128→    currentPrice <= levels.rotationHigh * bufferMultiplier;
   129→
   130→  // Detect false breakouts (SFP - Swing Failure Pattern)
   131→  // Wick beyond level but close inside
   132→  const falseBreakoutHigh =
   133→    currentHigh > levels.rotationHigh && currentPrice <= levels.rotationHigh;
   134→
   135→  const falseBreakoutLow =
   136→    currentLow < levels.rotationLow && currentPrice >= levels.rotationLow;
   137→
   138→  // HTF alignment check
   139→  const htfAligned = htfLevels
   140→    ? levels.state === htfLevels.state || htfLevels.state === 0
   141→    : true;
   142→
   143→  return {
   144→    current: levels,
   145→    htf: htfLevels,
   146→    signals: {
   147→      newUpRotation: false, // Set by comparing with previous state
   148→      newDownRotation: false,
   149→      invalidation: false,
   150→      atSupport,
   151→      atResistance,
   152→      falseBreakoutHigh,
   153→      falseBreakoutLow,
   154→      htfAligned,
   155→    },
   156→  };
   157→}
   158→
   159→// ============================================================================
   160→// State Management (for tracking rotation changes)
   161→// ============================================================================
   162→
   163→// In-memory state per mint for tracking rotation changes
   164→const rotationStateCache = new Map<
   165→  string,
   166→  {
   167→    previousState: RotationState;
   168→    previousLevels: RotationLevels;
   169→    lastUpdate: number;
   170→  }
   171→>();
   172→
   173→/**
   174→ * Update rotation state and detect changes.
   175→ * Returns analysis with new rotation/invalidation signals.
   176→ */
   177→export function updateRotationState(
   178→  mint: string,
   179→  newLevels: RotationLevels,
   180→  currentPrice: number,
   181→  currentHigh: number,
   182→  currentLow: number,
   183→  htfLevels?: RotationLevels,
   184→  levelBuffer: number = 0.5
   185→): RotationAnalysis {
   186→  const cached = rotationStateCache.get(mint);
   187→
   188→  const analysis = analyzeRotations(
   189→    currentPrice,
   190→    currentHigh,
   191→    currentLow,
   192→    newLevels,
   193→    htfLevels,
   194→    levelBuffer
   195→  );
   196→
   197→  // Detect state changes
   198→  if (cached) {
   199→    if (newLevels.state === 1 && cached.previousState !== 1) {
   200→      analysis.signals.newUpRotation = true;
   201→    }
   202→    if (newLevels.state === -1 && cached.previousState !== -1) {
   203→      analysis.signals.newDownRotation = true;
   204→    }
   205→    if (newLevels.state === 0 && cached.previousState !== 0) {
   206→      analysis.signals.invalidation = true;
   207→    }
   208→  }
   209→
   210→  // Update cache
   211→  rotationStateCache.set(mint, {
   212→    previousState: newLevels.state,
   213→    previousLevels: newLevels,
   214→    lastUpdate: Date.now(),
   215→  });
   216→
   217→  return analysis;
   218→}
   219→
   220→/**
   221→ * Clear rotation state for a mint
   222→ */
   223→export function clearRotationState(mint: string): void {
   224→  rotationStateCache.delete(mint);
   225→}
   226→
   227→/**
   228→ * Estimate rotation levels from market data when OHLCV is unavailable.
   229→ * Uses price change data to infer market structure.
   230→ */
   231→export function estimateRotationFromMarketData(
   232→  token: import('../api/types.js').TokenMarketData
   233→): RotationLevels | null {
   234→  const currentPrice = token.price_sol;
   235→  if (!currentPrice || currentPrice <= 0) return null;
   236→
   237→  // Calculate price at different timeframes
   238→  const price5mAgo = token.earliest_price_sol_5m > 0 ? token.earliest_price_sol_5m : currentPrice;
   239→  const price1hAgo = token.earliest_price_sol_1h > 0 ? token.earliest_price_sol_1h : currentPrice;
   240→
   241→  // Calculate price changes
   242→  const change5m = ((currentPrice - price5mAgo) / price5mAgo) * 100;
   243→  const change1h = ((currentPrice - price1hAgo) / price1hAgo) * 100;
   244→
   245→  // Determine rotation state from price action
   246→  // Upward rotation: price trending up (both 5m and 1h positive or strongly positive short-term)
   247→  // Downward rotation: price trending down
   248→  // Invalidation: mixed signals
   249→  let state: RotationState = 0;
   250→
   251→  if (change5m > 1 && change1h > 0) {
   252→    // Strong short-term bullish momentum with positive hourly trend
   253→    state = 1;
   254→  } else if (change5m < -1 && change1h < 0) {
   255→    // Strong short-term bearish momentum with negative hourly trend
   256→    state = -1;
   257→  } else if (change5m > 2) {
   258→    // Very strong 5m move overrides hourly
   259→    state = 1;
   260→  } else if (change5m < -2) {
   261→    state = -1;
   262→  }
   263→  // Otherwise stays at 0 (invalidation/ranging)
   264→
   265→  // Estimate rotation levels based on recent price range
   266→  // Use a percentage of current price as the range
   267→  const rangePercent = Math.max(Math.abs(change5m), 2); // At least 2% range
   268→  const halfRange = (rangePercent / 100) * currentPrice;
   269→
   270→  let rotationHigh: number;
   271→  let rotationLow: number;
   272→
   273→  if (state === 1) {
   274→    // Uptrend: high is current, low is support
   275→    rotationHigh = currentPrice;
   276→    rotationLow = Math.min(price5mAgo, currentPrice - halfRange);
   277→  } else if (state === -1) {
   278→    // Downtrend: low is current, high is resistance
   279→    rotationHigh = Math.max(price5mAgo, currentPrice + halfRange);
   280→    rotationLow = currentPrice;
   281→  } else {
   282→    // Ranging: use price range
   283→    rotationHigh = Math.max(currentPrice, price5mAgo) * 1.01;
   284→    rotationLow = Math.min(currentPrice, price5mAgo) * 0.99;
   285→  }
   286→
   287→  return {
   288→    rotationHigh,
   289→    rotationLow,
   290→    state,
   291→    barIndex: 0, // Unknown without OHLCV
   292→  };
   293→}
   294→
   295→/**
   296→ * Get current rotation levels for a mint (if cached)
   297→ */
   298→export function getRotationLevels(mint: string): RotationLevels | null {
   299→  return rotationStateCache.get(mint)?.previousLevels ?? null;
   300→}
   301→
   302→// ============================================================================
   303→// Rotations Rule Implementation
   304→// ============================================================================
   305→
   306→export class RotationsRule implements Rule<RotationsRuleConfig> {
   307→  config: RotationsRuleConfig;
   308→
   309→  constructor(config: RotationsRuleConfig) {
   310→    this.config = config;
   311→  }
   312→
   313→  analyze(context: AnalysisContext): Signal | null {
   314→    const { token, ohlcv } = context;
   315→
   316→    let levels: RotationLevels | null = null;
   317→    let currentHigh: number;
   318→    let currentLow: number;
   319→
   320→    // Try OHLCV-based calculation first
   321→    if (ohlcv && ohlcv.length >= 10) {
   322→      levels = calculateRotations(ohlcv);
   323→      const latestBar = ohlcv[ohlcv.length - 1];
   324→      currentHigh = latestBar?.high ?? token.price_sol;
   325→      currentLow = latestBar?.low ?? token.price_sol;
   326→    } else {
   327→      // Fallback: estimate rotation from market data price changes
   328→      levels = estimateRotationFromMarketData(token);
   329→      // Use price with small buffer for high/low estimation
   330→      currentHigh = token.price_sol * 1.001;
   331→      currentLow = token.price_sol * 0.999;
   332→    }
   333→
   334→    if (!levels) return null;
   335→
   336→    // Get current price info
   337→    const currentPrice = token.price_sol;
   338→
   339→    // Update state and get analysis
   340→    const analysis = updateRotationState(
   341→      token.mint,
   342→      levels,
   343→      currentPrice,
   344→      currentHigh,
   345→      currentLow,
   346→      undefined, // HTF levels would come from separate OHLCV fetch
   347→      this.config.levelBuffer
   348→    );
   349→
   350→    // Generate signals based on config
   351→    return this.generateSignal(token.mint, token.symbol, analysis);
   352→  }
   353→
   354→  private generateSignal(
   355→    mint: string,
   356→    symbol: string,
   357→    analysis: RotationAnalysis
   358→  ): Signal | null {
   359→    const { signals, current } = analysis;
   360→    const now = Date.now();
   361→
   362→    // HTF alignment check
   363→    if (this.config.requireHtfAlignment && !signals.htfAligned) {
   364→      return null;
   365→    }
   366→
   367→    // Signal on new upward rotation (BOS - Break of Structure)
   368→    if (this.config.signalOnRotation && signals.newUpRotation) {
   369→      return {
   370→        ruleId: this.config.id,
   371→        ruleName: this.config.name,
   372→        mint,
   373→        symbol,
   374→        type: 'buy',
   375→        strength: 0.8,
   376→        reason: `New upward rotation - structure shift bullish`,
   377→        data: {
   378→          rotationState: current.state,
   379→          rotationHigh: current.rotationHigh,
   380→          rotationLow: current.rotationLow,
   381→          signalType: 'new_rotation',
   382→        },
   383→        timestamp: now,
   384→      };
   385→    }
   386→
   387→    // Signal on new downward rotation
   388→    if (this.config.signalOnRotation && signals.newDownRotation) {
   389→      return {
   390→        ruleId: this.config.id,
   391→        ruleName: this.config.name,
   392→        mint,
   393→        symbol,
   394→        type: 'sell',
   395→        strength: 0.8,
   396→        reason: `New downward rotation - structure shift bearish`,
   397→        data: {
   398→          rotationState: current.state,
   399→          rotationHigh: current.rotationHigh,
   400→          rotationLow: current.rotationLow,
   401→          signalType: 'new_rotation',
   402→        },
   403→        timestamp: now,
   404→      };
   405→    }
   406→
   407→    // Signal on pullback to support in uptrend
   408→    if (
   409→      this.config.signalOnPullback &&
   410→      current.state === 1 &&
   411→      signals.atSupport
   412→    ) {
   413→      return {
   414→        ruleId: this.config.id,
   415→        ruleName: this.config.name,
   416→        mint,
   417→        symbol,
   418→        type: 'buy',
   419→        strength: 0.7,
   420→        reason: `Pullback to rotation support in uptrend`,
   421→        data: {
   422→          rotationState: current.state,
   423→          rotationHigh: current.rotationHigh,
   424→          rotationLow: current.rotationLow,
   425→          signalType: 'pullback_support',
   426→        },
   427→        timestamp: now,
   428→      };
   429→    }
   430→
   431→    // Signal on pullback to resistance in downtrend
   432→    if (
   433→      this.config.signalOnPullback &&
   434→      current.state === -1 &&
   435→      signals.atResistance
   436→    ) {
   437→      return {
   438→        ruleId: this.config.id,
   439→        ruleName: this.config.name,
   440→        mint,
   441→        symbol,
   442→        type: 'sell',
   443→        strength: 0.7,
   444→        reason: `Pullback to rotation resistance in downtrend`,
   445→        data: {
   446→          rotationState: current.state,
   447→          rotationHigh: current.rotationHigh,
   448→          rotationLow: current.rotationLow,
   449→          signalType: 'pullback_resistance',
   450→        },
   451→        timestamp: now,
   452→      };
   453→    }
   454→
   455→    // Signal on false breakout low (SFP) - bullish
   456→    if (this.config.signalOnSFP && signals.falseBreakoutLow) {
   457→      return {
   458→        ruleId: this.config.id,
   459→        ruleName: this.config.name,
   460→        mint,
   461→        symbol,
   462→        type: 'buy',
   463→        strength: 0.75,
   464→        reason: `False breakout below support (SFP) - liquidity grab`,
   465→        data: {
   466→          rotationState: current.state,
   467→          rotationHigh: current.rotationHigh,
   468→          rotationLow: current.rotationLow,
   469→          signalType: 'sfp_low',
   470→        },
   471→        timestamp: now,
   472→      };
   473→    }
   474→
   475→    // Signal on false breakout high (SFP) - bearish
   476→    if (this.config.signalOnSFP && signals.falseBreakoutHigh) {
   477→      return {
   478→        ruleId: this.config.id,
   479→        ruleName: this.config.name,
   480→        mint,
   481→        symbol,
   482→        type: 'sell',
   483→        strength: 0.75,
   484→        reason: `False breakout above resistance (SFP) - liquidity grab`,
   485→        data: {
   486→          rotationState: current.state,
   487→          rotationHigh: current.rotationHigh,
   488→          rotationLow: current.rotationLow,
   489→          signalType: 'sfp_high',
   490→        },
   491→        timestamp: now,
   492→      };
   493→    }
   494→
   495→    return null;
   496→  }
   497→}
   498→
   499→// ============================================================================
   500→// Default Config
   501→// ============================================================================
   502→
   503→export const DEFAULT_ROTATIONS_CONFIG: RotationsRuleConfig = {
   504→  id: 'rotations-default',
   505→  name: 'Rotations S/R',
   506→  description: 'Market structure via candlestick rotations',
   507→  enabled: true,
   508→  type: 'both',
   509→  ruleType: 'rotations',
   510→  levelBuffer: 0.5,
   511→  requireHtfAlignment: false,
   512→  signalOnRotation: true,
   513→  signalOnPullback: true,
   514→  signalOnSFP: true,
   515→};
   516→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
