     1→type Timeout = ReturnType<typeof setTimeout>;
     2→
     3→type PromiseOrPlain<T> = T | Promise<T>;
     4→
     5→type SyncOrAsyncFuncWithEmptyReturn = PromiseOrPlain<
     6→  () => PromiseOrPlain<void | undefined>
     7→>;
     8→
     9→type ConnectionState = {
    10→  componentIds: Set<string>;
    11→  wsConnected: boolean;
    12→  disconnectTimeout: Timeout | null;
    13→  initialDataFetching: boolean;
    14→  currentKey: string;
    15→  cleanup: SyncOrAsyncFuncWithEmptyReturn | null;
    16→  currentReconnectTimeout: number;
    17→  pendingReconnectTimeoutId: Timeout | null;
    18→};
    19→
    20→export type BaseConnectionCallbacks = {
    21→  onSubscribe: () => SyncOrAsyncFuncWithEmptyReturn;
    22→  onInitialData?: () => Promise<void>;
    23→};
    24→
    25→type ConnectionCheckArgs = {
    26→  connectionId: string;
    27→  callbacks: BaseConnectionCallbacks;
    28→  refetchKey: string;
    29→  isEnabled: boolean;
    30→};
    31→
    32→type CheckerState = {
    33→  isCheckerRunning: boolean;
    34→  isReconnectNeeded: boolean;
    35→  desiredState: ConnectionCheckArgs;
    36→};
    37→
    38→export const defaultRefetchKey = "default";
    39→
    40→class BaseConnectionManager {
    41→  // Public methods below
    42→
    43→  constructor() {
    44→    this.setupVisibilityChangeListener();
    45→  }
    46→
    47→  // We need it to queue sync calls to series of async calls that need to be executed in order
    48→  public queueConnectionCheck(data: ConnectionCheckArgs): void {
    49→    const checkerState = this.setConnectionDesiredState(
    50→      data.connectionId,
    51→      data
    52→    );
    53→
    54→    if (!checkerState.isCheckerRunning) {
    55→      this.runConnectionChecker(data.connectionId);
    56→    }
    57→  }
    58→
    59→  public queueReconnect(connectionId: string): void {
    60→    const checkerState = this.getConnectionDesiredState(connectionId);
    61→
    62→    checkerState.isReconnectNeeded = true;
    63→    checkerState.desiredState = { ...checkerState.desiredState };
    64→
    65→    if (!checkerState.isCheckerRunning) {
    66→      this.runConnectionChecker(connectionId);
    67→    }
    68→  }
    69→
    70→  public addSubscribedComponent(
    71→    connectionid: string,
    72→    componentId: string
    73→  ): void {
    74→    const state = this.getOrCreateConnectionState(connectionid);
    75→    state.componentIds.add(componentId);
    76→  }
    77→
    78→  public removeSubscribedComponent(
    79→    connectionId: string,
    80→    componentId: string
    81→  ): void {
    82→    const state = this.getOrCreateConnectionState(connectionId);
    83→    state.componentIds.delete(componentId);
    84→  }
    85→
    86→  // Private data below
    87→
    88→  private readonly connectionDesiredStates: Map<string, CheckerState> =
    89→    new Map();
    90→  private readonly connectionStates: Map<string, ConnectionState> = new Map();
    91→  private readonly defaultInitialData = async () => {};
    92→  private readonly DEFAULT_DISCONNECT_DEBOUNCE = 3000;
    93→  private readonly DEFAULT_CONNECTION_TIMEOUT = 8000;
    94→  private readonly DEFAULT_RECONNECT_TIMEOUT = 0;
    95→  private readonly DEFAULT_RECONNECT_MAX_TIMEOUT = 30000;
    96→  private readonly DEFAULT_RECONNECT_INCREMENT = 3000;
    97→
    98→  private isDocumentHidden = false;
    99→
   100→  // Private methods below
   101→
   102→  /**
   103→   * Sets up visibility change listener to handle tab switching.
   104→   * When tab becomes visible again:
   105→   * - Reset all reconnection timeouts (fresh start)
   106→   * - Immediately trigger reconnection for disconnected connections
   107→   */
   108→  private setupVisibilityChangeListener(): void {
   109→    if (typeof document === "undefined") return;
   110→
   111→    document.addEventListener("visibilitychange", () => {
   112→      const wasHidden = this.isDocumentHidden;
   113→      this.isDocumentHidden = document.hidden;
   114→
   115→      if (wasHidden && !document.hidden) {
   116→        // Tab became visible - trigger immediate reconnection
   117→        console.debug(
   118→          "[BaseConnectionManager] Tab became visible, checking connections..."
   119→        );
   120→        this.handleVisibilityRestored();
   121→      }
   122→    });
   123→
   124→    // Initialize state
   125→    this.isDocumentHidden = document.hidden;
   126→  }
   127→
   128→  /**
   129→   * Called when tab becomes visible again.
   130→   * Resets reconnection timeouts and triggers reconnection for disconnected connections.
   131→   */
   132→  private handleVisibilityRestored(): void {
   133→    for (const [connectionId, state] of this.connectionStates.entries()) {
   134→      if (state.pendingReconnectTimeoutId) {
   135→        clearTimeout(state.pendingReconnectTimeoutId);
   136→        state.pendingReconnectTimeoutId = null;
   137→      }
   138→
   139→      state.currentReconnectTimeout = this.DEFAULT_RECONNECT_TIMEOUT;
   140→
   141→      if (state.componentIds.size > 0 && !state.wsConnected) {
   142→        console.debug(
   143→          `[${connectionId}] Triggering reconnect after tab visibility restored`
   144→        );
   145→        this.queueReconnect(connectionId);
   146→      }
   147→    }
   148→  }
   149→
   150→  private async runConnectionChecker(connectionId: string) {
   151→    const checkerState = this.getConnectionDesiredState(connectionId);
   152→
   153→    checkerState.isCheckerRunning = true;
   154→
   155→    try {
   156→      let previousState = checkerState.desiredState;
   157→      while (true) {
   158→        const isReconnectNeeded = checkerState.isReconnectNeeded;
   159→
   160→        checkerState.isReconnectNeeded = false;
   161→
   162→        try {
   163→          await this.checkConnection(previousState, isReconnectNeeded);
   164→          // Reset per-connection timeout on success
   165→          const state = this.connectionStates.get(connectionId);
   166→          if (state) {
   167→            state.currentReconnectTimeout = this.DEFAULT_RECONNECT_TIMEOUT;
   168→          }
   169→        } catch (error) {
   170→          console.error(`[${connectionId}] Failed to connect`, error);
   171→
   172→          const state = this.getOrCreateConnectionState(connectionId);
   173→
   174→          // Don't schedule reconnect if document is hidden - wait for visibility restore
   175→          if (this.isDocumentHidden) {
   176→            console.debug(
   177→              `[${connectionId}] Document hidden, deferring reconnect until visible`
   178→            );
   179→          } else {
   180→            // Schedule reconnect with per-connection backoff
   181→            const reconnectDelay = state.currentReconnectTimeout;
   182→            console.debug(
   183→              `[${connectionId}] Scheduling reconnect in ${reconnectDelay}ms`
   184→            );
   185→
   186→            // Clear any existing pending timeout
   187→            if (state.pendingReconnectTimeoutId) {
   188→              clearTimeout(state.pendingReconnectTimeoutId);
   189→            }
   190→
   191→            state.pendingReconnectTimeoutId = setTimeout(() => {
   192→              state.pendingReconnectTimeoutId = null;
   193→              this.queueReconnect(connectionId);
   194→            }, reconnectDelay);
   195→
   196→            // Increase per-connection timeout for next failure
   197→            state.currentReconnectTimeout = Math.min(
   198→              state.currentReconnectTimeout + this.DEFAULT_RECONNECT_INCREMENT,
   199→              this.DEFAULT_RECONNECT_MAX_TIMEOUT
   200→            );
   201→          }
   202→        }
   203→
   204→        // If the desired state has not changed, break the loop
   205→        if (previousState === checkerState.desiredState) {
   206→          break;
   207→        } else {
   208→          previousState = checkerState.desiredState;
   209→        }
   210→      }
   211→    } finally {
   212→      checkerState.isCheckerRunning = false;
   213→    }
   214→  }
   215→
   216→  private getConnectionDesiredState(connectionId: string) {
   217→    const checkerState = this.connectionDesiredStates.get(connectionId);
   218→
   219→    if (!checkerState) {
   220→      throw new Error(`Connection checker state not found for ${connectionId}`);
   221→    }
   222→
   223→    return checkerState;
   224→  }
   225→
   226→  private setConnectionDesiredState(
   227→    connectionId: string,
   228→    desiredState: ConnectionCheckArgs
   229→  ) {
   230→    let checkerState = this.connectionDesiredStates.get(connectionId);
   231→
   232→    if (!checkerState) {
   233→      checkerState = {
   234→        isCheckerRunning: false,
   235→        isReconnectNeeded: false,
   236→        desiredState: desiredState,
   237→      };
   238→      this.connectionDesiredStates.set(connectionId, checkerState);
   239→    }
   240→
   241→    checkerState.desiredState = desiredState;
   242→
   243→    return checkerState;
   244→  }
   245→
   246→  private async checkConnection(
   247→    data: ConnectionCheckArgs,
   248→    isReconnect: boolean = false
   249→  ) {
   250→    const state = this.getOrCreateConnectionState(data.connectionId);
   251→
   252→    // If disabled, ensure we don't connect and perform cleanup if needed
   253→    if (!data.isEnabled) {
   254→      if (state.wsConnected) {
   255→        await this.disconnect(data.connectionId);
   256→      }
   257→      return;
   258→    }
   259→
   260→    if (state.componentIds.size > 0) {
   261→      if (state.disconnectTimeout) {
   262→        clearTimeout(state.disconnectTimeout);
   263→        state.disconnectTimeout = null;
   264→      }
   265→
   266→      if (
   267→        (state.currentKey !== data.refetchKey &&
   268→          state.currentKey !== defaultRefetchKey) ||
   269→        isReconnect
   270→      ) {
   271→        await this.handleReconnect(data);
   272→        return;
   273→      }
   274→
   275→      if (state.wsConnected) return;
   276→
   277→      if (!state.initialDataFetching) {
   278→        void this.fetchInitialData(data.callbacks, data.connectionId);
   279→      }
   280→
   281→      await this.connect(data.callbacks, data.connectionId);
   282→
   283→      state.currentKey = data.refetchKey;
   284→    } else {
   285→      if (state.disconnectTimeout) return;
   286→
   287→      state.disconnectTimeout = setTimeout(async () => {
   288→        await this.disconnect(data.connectionId);
   289→      }, this.DEFAULT_DISCONNECT_DEBOUNCE);
   290→    }
   291→  }
   292→
   293→  private getOrCreateConnectionState(key: string): ConnectionState {
   294→    let state = this.connectionStates.get(key);
   295→
   296→    if (!state) {
   297→      state = {
   298→        componentIds: new Set<string>(),
   299→        wsConnected: false,
   300→        disconnectTimeout: null,
   301→        initialDataFetching: false,
   302→        currentKey: defaultRefetchKey,
   303→        cleanup: null,
   304→        currentReconnectTimeout: this.DEFAULT_RECONNECT_TIMEOUT,
   305→        pendingReconnectTimeoutId: null,
   306→      };
   307→      this.connectionStates.set(key, state);
   308→    }
   309→    return state;
   310→  }
   311→
   312→  private async fetchInitialData(
   313→    callbacks: BaseConnectionCallbacks,
   314→    connectionId: string
   315→  ) {
   316→    const state = this.getOrCreateConnectionState(connectionId);
   317→    state.initialDataFetching = true;
   318→
   319→    const { onInitialData = this.defaultInitialData } = callbacks;
   320→
   321→    await onInitialData()
   322→      .catch(() => {
   323→        console.error(`[${connectionId}] Failed to fetch initial data`);
   324→      })
   325→      .finally(() => {
   326→        state.initialDataFetching = false;
   327→      });
   328→  }
   329→
   330→  private async connect(
   331→    callbacks: BaseConnectionCallbacks,
   332→    connectionId: string
   333→  ) {
   334→    const state = this.getOrCreateConnectionState(connectionId);
   335→
   336→    try {
   337→      if (state.wsConnected) return;
   338→
   339→      const timeoutPromise = new Promise((_, reject) => {
   340→        setTimeout(
   341→          () => reject(new Error("Connection timeout")),
   342→          this.DEFAULT_CONNECTION_TIMEOUT
   343→        );
   344→      });
   345→
   346→      const cleanup = await Promise.race([
   347→        callbacks.onSubscribe(),
   348→        timeoutPromise,
   349→      ]);
   350→
   351→      state.cleanup = cleanup as SyncOrAsyncFuncWithEmptyReturn;
   352→      state.wsConnected = true;
   353→      console.debug(
   354→        `[${connectionId}] Connected. Current subs amount: ${state.componentIds.size}`
   355→      );
   356→    } catch (error) {
   357→      // If connection fails (e.g., due to invalid params), do not mark as connected
   358→      state.cleanup = null;
   359→      state.wsConnected = false;
   360→      throw error;
   361→    }
   362→  }
   363→
   364→  private async disconnect(connectionId: string) {
   365→    const state = this.getOrCreateConnectionState(connectionId);
   366→
   367→    try {
   368→      if (state.cleanup) {
   369→        if (typeof state.cleanup === "function") {
   370→          await state.cleanup();
   371→        } else {
   372→          await state.cleanup.then(fn => fn?.());
   373→        }
   374→      }
   375→
   376→      // Clear any pending reconnect timeout
   377→      if (state.pendingReconnectTimeoutId) {
   378→        clearTimeout(state.pendingReconnectTimeoutId);
   379→        state.pendingReconnectTimeoutId = null;
   380→      }
   381→
   382→      // Reset state immediately to block concurrent connects
   383→      state.cleanup = null;
   384→      state.wsConnected = false;
   385→      state.disconnectTimeout = null;
   386→      state.currentKey = defaultRefetchKey;
   387→      // Reset reconnect timeout on intentional disconnect
   388→      state.currentReconnectTimeout = this.DEFAULT_RECONNECT_TIMEOUT;
   389→    } finally {
   390→      console.debug(
   391→        `[${connectionId}] Disconnected. Current subs amount: ${state.componentIds.size}`
   392→      );
   393→    }
   394→  }
   395→
   396→  private async handleReconnect(data: ConnectionCheckArgs) {
   397→    const state = this.getOrCreateConnectionState(data.connectionId);
   398→
   399→    if (state.disconnectTimeout) {
   400→      clearTimeout(state.disconnectTimeout);
   401→      state.disconnectTimeout = null;
   402→    }
   403→
   404→    // If there are no active components, just ensure cleanup
   405→    if (state.componentIds.size === 0) {
   406→      if (state.wsConnected) {
   407→        await this.disconnect(data.connectionId);
   408→      }
   409→      return;
   410→    }
   411→
   412→    if (!data.isEnabled) {
   413→      if (state.wsConnected) {
   414→        await this.disconnect(data.connectionId);
   415→      }
   416→      return;
   417→    }
   418→
   419→    if (state.wsConnected) {
   420→      await this.disconnect(data.connectionId);
   421→    }
   422→
   423→    void this.fetchInitialData(data.callbacks, data.connectionId);
   424→    await this.connect(data.callbacks, data.connectionId);
   425→
   426→    state.currentKey = data.refetchKey;
   427→  }
   428→}
   429→
   430→const baseConnectionManager = new BaseConnectionManager();
   431→
   432→export default baseConnectionManager;
   433→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
