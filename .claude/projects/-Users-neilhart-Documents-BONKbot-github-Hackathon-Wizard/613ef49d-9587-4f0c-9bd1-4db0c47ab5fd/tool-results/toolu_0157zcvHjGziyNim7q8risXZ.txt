The file /Users/neilhart/Documents/BONKbot/github/token-analysis-autopilot/src/trading/magic-exits.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→/**
     2→ * Magic Exit Management - Automatic Exit Strategies Based on Market Structure
     3→ *
     4→ * ============================================================================
     5→ * STRATEGY OVERVIEW
     6→ * ============================================================================
     7→ *
     8→ * "Magic Exits" are automatic exit mechanisms that use rotation-based support
     9→ * and resistance levels to manage open positions. Instead of fixed percentage
    10→ * stops or take-profits, we exit based on actual market structure.
    11→ *
    12→ * ============================================================================
    13→ * WHY STRUCTURE-BASED EXITS?
    14→ * ============================================================================
    15→ *
    16→ * Fixed percentage exits (e.g., "stop at -5%, take profit at +10%") don't
    17→ * account for where meaningful price levels actually are. A 5% stop might:
    18→ *   - Be too tight if support is 7% below entry → gets stopped out before bounce
    19→ *   - Be too loose if support is 2% below entry → gives back unnecessary profit
    20→ *
    21→ * Structure-based exits solve this by using actual support/resistance:
    22→ *   - Stop loss below actual support (where buyers are expected)
    23→ *   - Take profit at actual resistance (where sellers are expected)
    24→ *
    25→ * ============================================================================
    26→ * EXIT TYPES
    27→ * ============================================================================
    28→ *
    29→ * 1. MAGIC TAKE PROFIT (TP)
    30→ *    Trigger: Price approaches or exceeds rotation resistance (rotationHigh)
    31→ *    Rationale: Resistance represents where price previously reversed. Taking
    32→ *               profit here captures gains before potential rejection.
    33→ *    Condition: Must be in profit (prevents exiting losing trades at resistance)
    34→ *
    35→ * 2. MAGIC STOP LOSS (SL)
    36→ *    Trigger: Price breaks below rotation support (rotationLow)
    37→ *    Rationale: Support break invalidates bullish structure. The reason for
    38→ *               the trade (bullish structure) no longer exists.
    39→ *    Condition: No profit requirement (cut losses regardless)
    40→ *
    41→ * 3. MAGIC TRAILING STOP LOSS (TSL) - TODO
    42→ *    Trigger: Price closes below Williams fractal trailing stop
    43→ *    Rationale: Locks in profits as trade moves in your favor while giving
    44→ *               room for normal pullbacks
    45→ *    Implementation: Trail to fractal swing lows (for longs)
    46→ *
    47→ * ============================================================================
    48→ * INTEGRATION WITH ROTATIONS
    49→ * ============================================================================
    50→ *
    51→ * Magic exits use the same rotation levels calculated by the Rotations rule:
    52→ *   - rotationHigh = resistance (TP zone)
    53→ *   - rotationLow = support (SL zone)
    54→ *
    55→ * This creates coherence: entries are at support, exits are at resistance,
    56→ * and stops are when support breaks. All based on the same structure model.
    57→ *
    58→ * ============================================================================
    59→ * TRIGGER MECHANICS
    60→ * ============================================================================
    61→ *
    62→ * TP Trigger (default 0.5% buffer):
    63→ *   - Price within 0.5% of rotationHigh AND in profit → EXIT
    64→ *   - OR price >= rotationHigh AND in profit → EXIT
    65→ *
    66→ * SL Trigger (default 0.5% buffer):
    67→ *   - Price is 0.5%+ below rotationLow → EXIT
    68→ *   - No profit requirement (we're cutting losses)
    69→ *
    70→ * The buffer prevents:
    71→ *   - TP: Missing exits because price turned just before resistance
    72→ *   - SL: Whipsawing on exact level touches
    73→ */
    74→
    75→import type { TokenMarketData } from '../api/types.js';
    76→import type { PaperTrade } from './types.js';
    77→import { paperTracker } from './paper-tracker.js';
    78→import {
    79→  getRotationLevels,
    80→  estimateRotationFromMarketData,
    81→  type RotationLevels,
    82→} from '../rules/rotations.js';
    83→
    84→// ============================================================================
    85→// TYPES
    86→// ============================================================================
    87→
    88→/**
    89→ * Configuration for magic exit strategies.
    90→ * Each exit type can be individually enabled/disabled with custom thresholds.
    91→ */
    92→export interface MagicExitConfig {
    93→  // ========================================================================
    94→  // TAKE PROFIT SETTINGS
    95→  // ========================================================================
    96→  /** Enable magic take profit at rotation resistance */
    97→  tpEnabled: boolean;
    98→  /**
    99→   * How close to resistance to trigger TP (percentage).
   100→   * Lower = more aggressive (exit earlier), Higher = more conservative.
   101→   * Example: 0.5 means exit when within 0.5% of resistance.
   102→   */
   103→  tpTriggerPercent: number;
   104→
   105→  // ========================================================================
   106→  // STOP LOSS SETTINGS
   107→  // ========================================================================
   108→  /** Enable magic stop loss on support break */
   109→  slEnabled: boolean;
   110→  /**
   111→   * How far below support to trigger SL (percentage).
   112→   * Lower = tighter stop (less loss, more false triggers).
   113→   * Higher = looser stop (more loss, fewer false triggers).
   114→   * Example: 0.5 means exit when 0.5% below support.
   115→   */
   116→  slTriggerPercent: number;
   117→
   118→  // ========================================================================
   119→  // TRAILING STOP LOSS SETTINGS (TODO)
   120→  // ========================================================================
   121→  /** Enable Williams fractal trailing stop loss */
   122→  tslEnabled: boolean;
   123→}
   124→
   125→/**
   126→ * Result of checking a single trade for exit conditions.
   127→ */
   128→export interface ExitCheck {
   129→  /** Whether an exit should be executed */
   130→  shouldExit: boolean;
   131→  /** Reason for exit (for logging and analytics) */
   132→  reason: 'tp_resistance' | 'sl_support_break' | 'tsl_fractal' | null;
   133→  /** Price at which to execute exit */
   134→  exitPrice: number;
   135→  /** Rotation levels used for this check (for reference) */
   136→  rotationLevels?: RotationLevels;
   137→  /** Human-readable details about why exit triggered */
   138→  details?: string;
   139→}
   140→
   141→// ============================================================================
   142→// DEFAULT CONFIGURATION
   143→// ============================================================================
   144→
   145→/**
   146→ * Default magic exit configuration.
   147→ *
   148→ * These defaults are tuned for meme coin trading:
   149→ *   - 0.5% TP buffer: Captures most of the move to resistance
   150→ *   - 0.5% SL buffer: Allows for small wicks without triggering
   151→ *   - TSL disabled: Requires OHLCV data which may not be available
   152→ */
   153→export const DEFAULT_MAGIC_EXIT_CONFIG: MagicExitConfig = {
   154→  tpEnabled: true,
   155→  tpTriggerPercent: 0.5, // Exit when within 0.5% of resistance
   156→
   157→  slEnabled: true,
   158→  slTriggerPercent: 0.5, // Exit when 0.5% below support
   159→
   160→  tslEnabled: false, // TODO: Implement Williams TSL (requires OHLCV)
   161→};
   162→
   163→// ============================================================================
   164→// MAGIC EXIT CHECKER
   165→// ============================================================================
   166→
   167→/**
   168→ * MagicExitChecker - Monitors open trades and triggers structure-based exits.
   169→ *
   170→ * Usage:
   171→ *   1. Create instance with config
   172→ *   2. Call checkExit() or checkAllTrades() with market data
   173→ *   3. Call executeExits() to close trades that should exit
   174→ *
   175→ * The checker uses rotation levels from the rotations rule cache, or estimates
   176→ * them from market data if not cached. This ensures consistency with entry signals.
   177→ */
   178→export class MagicExitChecker {
   179→  private config: MagicExitConfig;
   180→
   181→  constructor(config: Partial<MagicExitConfig> = {}) {
   182→    this.config = { ...DEFAULT_MAGIC_EXIT_CONFIG, ...config };
   183→  }
   184→
   185→  /**
   186→   * Update configuration at runtime.
   187→   * Useful for adjusting thresholds without restarting.
   188→   */
   189→  updateConfig(config: Partial<MagicExitConfig>): void {
   190→    this.config = { ...this.config, ...config };
   191→  }
   192→
   193→  /**
   194→   * Check if a single trade should exit based on magic exit rules.
   195→   *
   196→   * Flow:
   197→   *   1. Get rotation levels for this token (from cache or estimate)
   198→   *   2. Check TP condition (approaching resistance, in profit)
   199→   *   3. Check SL condition (below support)
   200→   *   4. Return first triggered exit condition
   201→   *
   202→   * @param trade - Open paper trade to check
   203→   * @param marketData - Current market data for the token
   204→   * @returns ExitCheck with shouldExit and reason
   205→   */
   206→  checkExit(trade: PaperTrade, marketData: TokenMarketData): ExitCheck {
   207→    const currentPrice = marketData.price_sol;
   208→
   209→    // ========================================================================
   210→    // GET ROTATION LEVELS
   211→    // ========================================================================
   212→    // First try to get cached levels from the rotations rule.
   213→    // If not cached (token not analyzed by rotations rule), estimate from
   214→    // market data. This ensures we always have some structure to work with.
   215→    let levels = getRotationLevels(trade.mint);
   216→    if (!levels) {
   217→      levels = estimateRotationFromMarketData(marketData);
   218→    }
   219→
   220→    if (!levels) {
   221→      // Can't determine structure - no exit signal
   222→      return { shouldExit: false, reason: null, exitPrice: currentPrice };
   223→    }
   224→
   225→    // ========================================================================
   226→    // CHECK MAGIC TAKE PROFIT (for long positions)
   227→    // ========================================================================
   228→    // Only check TP for buy trades (long positions).
   229→    // TP triggers when price approaches resistance AND we're in profit.
   230→    if (this.config.tpEnabled && trade.action === 'buy') {
   231→      const tpCheck = this.checkTakeProfit(trade, currentPrice, levels);
   232→      if (tpCheck.shouldExit) return tpCheck;
   233→    }
   234→
   235→    // ========================================================================
   236→    // CHECK MAGIC STOP LOSS (for long positions)
   237→    // ========================================================================
   238→    // Only check SL for buy trades (long positions).
   239→    // SL triggers when price breaks below support (no profit requirement).
   240→    if (this.config.slEnabled && trade.action === 'buy') {
   241→      const slCheck = this.checkStopLoss(trade, currentPrice, levels);
   242→      if (slCheck.shouldExit) return slCheck;
   243→    }
   244→
   245→    // ========================================================================
   246→    // TODO: CHECK MAGIC TRAILING STOP LOSS
   247→    // ========================================================================
   248→    // Williams fractal TSL would be checked here when implemented.
   249→    // if (this.config.tslEnabled) { ... }
   250→
   251→    // No exit conditions met
   252→    return {
   253→      shouldExit: false,
   254→      reason: null,
   255→      exitPrice: currentPrice,
   256→      rotationLevels: levels,
   257→    };
   258→  }
   259→
   260→  /**
   261→   * Check Magic Take Profit condition.
   262→   *
   263→   * STRATEGY RATIONALE:
   264→   * Rotation resistance (rotationHigh) represents where price previously
   265→   * reversed. Rather than hoping for continued momentum, we capture gains
   266→   * before the expected rejection. This is conservative but consistent.
   267→   *
   268→   * TRIGGER CONDITIONS:
   269→   * 1. Price within tpTriggerPercent of resistance AND in profit
   270→   * 2. OR price at/above resistance AND in profit
   271→   *
   272→   * The profit requirement prevents exiting losing trades at resistance
   273→   * (which would lock in losses instead of giving recovery chance).
   274→   *
   275→   * @param trade - Open trade to check
   276→   * @param currentPrice - Current price
   277→   * @param levels - Rotation levels
   278→   * @returns ExitCheck for TP
   279→   */
   280→  private checkTakeProfit(
   281→    trade: PaperTrade,
   282→    currentPrice: number,
   283→    levels: RotationLevels
   284→  ): ExitCheck {
   285→    const { rotationHigh } = levels;
   286→
   287→    // Calculate distance to resistance as percentage
   288→    // Positive = below resistance, Negative = above resistance
   289→    const distanceToResistance = ((rotationHigh - currentPrice) / currentPrice) * 100;
   290→
   291→    // Calculate current P&L percentage
   292→    const pnlPercent = ((currentPrice - trade.entryPriceSol) / trade.entryPriceSol) * 100;
   293→
   294→    // ========================================================================
   295→    // TRIGGER: APPROACHING RESISTANCE AND IN PROFIT
   296→    // ========================================================================
   297→    // If we're within the trigger distance of resistance AND making money,
   298→    // take profit now rather than risk rejection.
   299→    if (distanceToResistance <= this.config.tpTriggerPercent && pnlPercent > 0) {
   300→      return {
   301→        shouldExit: true,
   302→        reason: 'tp_resistance',
   303→        exitPrice: currentPrice,
   304→        rotationLevels: levels,
   305→        details: `Price ${currentPrice.toFixed(8)} within ${distanceToResistance.toFixed(2)}% of resistance ${rotationHigh.toFixed(8)} | P&L: +${pnlPercent.toFixed(2)}%`,
   306→      };
   307→    }
   308→
   309→    // ========================================================================
   310→    // TRIGGER: AT OR ABOVE RESISTANCE AND IN PROFIT
   311→    // ========================================================================
   312→    // Price has reached or exceeded resistance. Even if it continues higher,
   313→    // we've captured the expected move. Take profit on strength.
   314→    if (currentPrice >= rotationHigh && pnlPercent > 0) {
   315→      return {
   316→        shouldExit: true,
   317→        reason: 'tp_resistance',
   318→        exitPrice: currentPrice,
   319→        rotationLevels: levels,
   320→        details: `Price ${currentPrice.toFixed(8)} at/above resistance ${rotationHigh.toFixed(8)} | P&L: +${pnlPercent.toFixed(2)}%`,
   321→      };
   322→    }
   323→
   324→    // TP not triggered
   325→    return { shouldExit: false, reason: null, exitPrice: currentPrice, rotationLevels: levels };
   326→  }
   327→
   328→  /**
   329→   * Check Magic Stop Loss condition.
   330→   *
   331→   * STRATEGY RATIONALE:
   332→   * Rotation support (rotationLow) represents where buyers previously stepped in.
   333→   * If price breaks below this level, the bullish structure that justified our
   334→   * entry is invalidated. We exit to prevent further losses.
   335→   *
   336→   * TRIGGER CONDITIONS:
   337→   * - Price is slTriggerPercent below support
   338→   *
   339→   * No profit requirement - we cut losses regardless of P&L. The goal is
   340→   * capital preservation when the trade thesis (bullish structure) is wrong.
   341→   *
   342→   * WHY NOT EXIT AT EXACT SUPPORT?
   343→   * A small buffer prevents whipsaws from wicks that briefly touch support
   344→   * but don't indicate genuine breakdown. The 0.5% default allows for normal
   345→   * volatility while still protecting against real support breaks.
   346→   *
   347→   * @param trade - Open trade to check
   348→   * @param currentPrice - Current price
   349→   * @param levels - Rotation levels
   350→   * @returns ExitCheck for SL
   351→   */
   352→  private checkStopLoss(
   353→    trade: PaperTrade,
   354→    currentPrice: number,
   355→    levels: RotationLevels
   356→  ): ExitCheck {
   357→    const { rotationLow } = levels;
   358→
   359→    // Calculate how far below support we are (as percentage)
   360→    // Positive = below support, Negative = above support
   361→    const distanceBelowSupport = ((rotationLow - currentPrice) / currentPrice) * 100;
   362→
   363→    // ========================================================================
   364→    // TRIGGER: SUPPORT BREAK
   365→    // ========================================================================
   366→    // Price has broken below support by more than the trigger threshold.
   367→    // The bullish structure is invalidated - exit to limit losses.
   368→    if (distanceBelowSupport >= this.config.slTriggerPercent) {
   369→      const pnlPercent = ((currentPrice - trade.entryPriceSol) / trade.entryPriceSol) * 100;
   370→
   371→      return {
   372→        shouldExit: true,
   373→        reason: 'sl_support_break',
   374→        exitPrice: currentPrice,
   375→        rotationLevels: levels,
   376→        details: `Price ${currentPrice.toFixed(8)} broke support ${rotationLow.toFixed(8)} by ${distanceBelowSupport.toFixed(2)}% | P&L: ${pnlPercent.toFixed(2)}%`,
   377→      };
   378→    }
   379→
   380→    // SL not triggered
   381→    return { shouldExit: false, reason: null, exitPrice: currentPrice, rotationLevels: levels };
   382→  }
   383→
   384→  /**
   385→   * Check all open trades for exit conditions.
   386→   *
   387→   * This is the batch version of checkExit() - iterates through all open
   388→   * paper trades and returns those that should be closed.
   389→   *
   390→   * @param marketDataMap - Map of mint -> market data for all tokens
   391→   * @returns Array of trades that should exit with their exit details
   392→   */
   393→  checkAllTrades(marketDataMap: Map<string, TokenMarketData>): Array<{
   394→    trade: PaperTrade;
   395→    exit: ExitCheck;
   396→  }> {
   397→    const exits: Array<{ trade: PaperTrade; exit: ExitCheck }> = [];
   398→
   399→    const openTrades = paperTracker.getOpenTrades();
   400→
   401→    for (const trade of openTrades) {
   402→      const marketData = marketDataMap.get(trade.mint);
   403→      if (!marketData) continue; // Skip if no market data available
   404→
   405→      const exit = this.checkExit(trade, marketData);
   406→      if (exit.shouldExit) {
   407→        exits.push({ trade, exit });
   408→      }
   409→    }
   410→
   411→    return exits;
   412→  }
   413→
   414→  /**
   415→   * Execute magic exits for all triggered trades.
   416→   *
   417→   * This is the main entry point for the run loop - checks all trades and
   418→   * closes those that meet exit conditions.
   419→   *
   420→   * @param marketDataMap - Map of mint -> market data
   421→   * @param quiet - Suppress console output (for bulk scanning)
   422→   * @returns Array of trades that were closed
   423→   */
   424→  async executeExits(
   425→    marketDataMap: Map<string, TokenMarketData>,
   426→    quiet: boolean = false
   427→  ): Promise<PaperTrade[]> {
   428→    const closedTrades: PaperTrade[] = [];
   429→    const exitsToExecute = this.checkAllTrades(marketDataMap);
   430→
   431→    for (const { trade, exit } of exitsToExecute) {
   432→      const marketData = marketDataMap.get(trade.mint);
   433→      if (!marketData) continue;
   434→
   435→      // Close the paper trade
   436→      const closed = paperTracker.closeTrade(
   437→        trade.id,
   438→        exit.exitPrice,
   439→        marketData.price_usd
   440→      );
   441→
   442→      if (closed) {
   443→        closedTrades.push(closed);
   444→
   445→        // Log the exit (unless quiet mode)
   446→        if (!quiet) {
   447→          const reasonLabel = this.getReasonLabel(exit.reason);
   448→          const pnlSign = (closed.pnlPercent ?? 0) >= 0 ? '+' : '';
   449→          console.log(
   450→            `\n[MAGIC ${reasonLabel}] ${closed.symbol} | ${pnlSign}${closed.pnlPercent?.toFixed(2)}%`
   451→          );
   452→          if (exit.details) {
   453→            console.log(`  ${exit.details}`);
   454→          }
   455→        }
   456→      }
   457→    }
   458→
   459→    // Persist closed trades
   460→    if (closedTrades.length > 0) {
   461→      await paperTracker.save();
   462→    }
   463→
   464→    return closedTrades;
   465→  }
   466→
   467→  /**
   468→   * Get human-readable label for exit reason.
   469→   * Used in logging and UI display.
   470→   */
   471→  private getReasonLabel(reason: ExitCheck['reason']): string {
   472→    switch (reason) {
   473→      case 'tp_resistance':
   474→        return 'TP'; // Take Profit
   475→      case 'sl_support_break':
   476→        return 'SL'; // Stop Loss
   477→      case 'tsl_fractal':
   478→        return 'TSL'; // Trailing Stop Loss
   479→      default:
   480→        return 'EXIT';
   481→    }
   482→  }
   483→
   484→  /**
   485→   * Get current configuration.
   486→   * Returns a copy to prevent external mutation.
   487→   */
   488→  getConfig(): MagicExitConfig {
   489→    return { ...this.config };
   490→  }
   491→}
   492→
   493→// ============================================================================
   494→// SINGLETON INSTANCE
   495→// ============================================================================
   496→
   497→/**
   498→ * Default magic exit checker instance.
   499→ * Used by the CLI run loop for automatic exit management.
   500→ *
   501→ * The singleton pattern ensures:
   502→ *   1. Consistent configuration across the application
   503→ *   2. No duplicate instances checking the same trades
   504→ *   3. Easy access without dependency injection
   505→ */
   506→export const magicExits = new MagicExitChecker();
   507→