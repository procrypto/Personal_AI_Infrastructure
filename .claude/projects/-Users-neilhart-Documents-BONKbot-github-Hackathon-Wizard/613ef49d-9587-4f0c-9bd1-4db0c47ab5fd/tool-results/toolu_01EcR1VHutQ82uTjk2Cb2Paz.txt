     1→/**
     2→ * Trade Trigger
     3→ *
     4→ * Handles triggering trades based on analysis signals.
     5→ * Supports both paper trading and (future) live LOIS integration.
     6→ */
     7→
     8→import type { Signal } from '../rules/types.js';
     9→import type { TriggerConfig } from '../config/types.js';
    10→import type { TriggerEvent, PaperTrade } from './types.js';
    11→import { paperTracker } from './paper-tracker.js';
    12→
    13→interface TriggerResult {
    14→  triggered: boolean;
    15→  reason?: string;
    16→  trade?: PaperTrade;
    17→  event: TriggerEvent;
    18→}
    19→
    20→// Track last trigger time per mint for cooldown
    21→const lastTriggerTime = new Map<string, number>();
    22→
    23→export class TradeTrigger {
    24→  constructor(private config: TriggerConfig) {}
    25→
    26→  updateConfig(config: TriggerConfig): void {
    27→    this.config = config;
    28→  }
    29→
    30→  async trigger(params: {
    31→    mint: string;
    32→    symbol: string;
    33→    action: 'buy' | 'sell';
    34→    priceSol: number;
    35→    priceUsd: number;
    36→    ruleSetId: string;
    37→    signals: Signal[];
    38→    confidence: number;
    39→  }): Promise<TriggerResult> {
    40→    const event: TriggerEvent = {
    41→      timestamp: Date.now(),
    42→      mint: params.mint,
    43→      symbol: params.symbol,
    44→      action: params.action,
    45→      ruleSetId: params.ruleSetId,
    46→      signals: params.signals.map(s => ({
    47→        ruleId: s.ruleId,
    48→        ruleName: s.ruleName,
    49→        reason: s.reason,
    50→        strength: s.strength,
    51→      })),
    52→      confidence: params.confidence,
    53→      triggered: false,
    54→    };
    55→
    56→    // Check if triggers are enabled
    57→    if (!this.config.enabled) {
    58→      event.reason = 'Triggers disabled';
    59→      paperTracker.recordEvent(event);
    60→      return { triggered: false, reason: event.reason, event };
    61→    }
    62→
    63→    // Check cooldown
    64→    const lastTime = lastTriggerTime.get(params.mint) ?? 0;
    65→    const elapsed = Date.now() - lastTime;
    66→    if (elapsed < this.config.cooldownMs) {
    67→      event.reason = `Cooldown: ${Math.ceil((this.config.cooldownMs - elapsed) / 1000)}s remaining`;
    68→      paperTracker.recordEvent(event);
    69→      return { triggered: false, reason: event.reason, event };
    70→    }
    71→
    72→    // Check for existing open trade on this mint
    73→    const existingTrade = paperTracker.getOpenTradeForMint(params.mint);
    74→    if (existingTrade) {
    75→      // If same direction, skip
    76→      if (existingTrade.action === params.action) {
    77→        event.reason = `Already have ${params.action} position open`;
    78→        paperTracker.recordEvent(event);
    79→        return { triggered: false, reason: event.reason, event };
    80→      }
    81→      // If opposite direction, close existing trade first
    82→      const closed = paperTracker.closeTrade(existingTrade.id, params.priceSol, params.priceUsd);
    83→      if (closed) {
    84→        console.log(`[PAPER] Closed ${closed.action} position: ${closed.pnlPercent?.toFixed(2)}% P&L`);
    85→      }
    86→    }
    87→
    88→    // Determine position size
    89→    let positionSizeSol = this.config.defaultPositionSizeSol;
    90→    // Scale by confidence (50-100% of default size)
    91→    positionSizeSol *= 0.5 + (params.confidence * 0.5);
    92→    // Cap at max
    93→    positionSizeSol = Math.min(positionSizeSol, this.config.maxPositionSizeSol);
    94→
    95→    // Execute based on mode
    96→    if (this.config.mode === 'paper') {
    97→      const trade = paperTracker.openTrade({
    98→        mint: params.mint,
    99→        symbol: params.symbol,
   100→        action: params.action,
   101→        priceSol: params.priceSol,
   102→        priceUsd: params.priceUsd,
   103→        positionSizeSol,
   104→        ruleSetId: params.ruleSetId,
   105→        signalStrength: params.confidence,
   106→        reason: params.signals.map(s => s.reason).join('; '),
   107→      });
   108→
   109→      event.triggered = true;
   110→      event.tradeId = trade.id;
   111→      paperTracker.recordEvent(event);
   112→      lastTriggerTime.set(params.mint, Date.now());
   113→
   114→      console.log(`\n[PAPER TRADE] ${params.action.toUpperCase()} ${params.symbol}`);
   115→      console.log(`  Position: ${positionSizeSol.toFixed(4)} SOL`);
   116→      console.log(`  Price: ${params.priceSol} SOL ($${params.priceUsd.toFixed(6)})`);
   117→      console.log(`  Confidence: ${(params.confidence * 100).toFixed(0)}%`);
   118→      console.log(`  Trade ID: ${trade.id}`);
   119→
   120→      return { triggered: true, trade, event };
   121→    } else {
   122→      // Live mode - would integrate with LOIS here
   123→      event.reason = 'Live LOIS integration not yet implemented';
   124→      event.triggered = false;
   125→      paperTracker.recordEvent(event);
   126→
   127→      console.log(`\n[LOIS TRIGGER - NOT IMPLEMENTED]`);
   128→      console.log(`  Would ${params.action}: ${params.symbol}`);
   129→      console.log(`  Size: ${positionSizeSol.toFixed(4)} SOL`);
   130→
   131→      return { triggered: false, reason: event.reason, event };
   132→    }
   133→  }
   134→
   135→  // Helper to close a position by mint
   136→  async closePosition(mint: string, currentPriceSol: number, currentPriceUsd: number): Promise<PaperTrade | null> {
   137→    const trade = paperTracker.getOpenTradeForMint(mint);
   138→    if (!trade) return null;
   139→
   140→    const closed = paperTracker.closeTrade(trade.id, currentPriceSol, currentPriceUsd);
   141→    if (closed) {
   142→      await paperTracker.save();
   143→      console.log(`\n[PAPER] Closed position: ${closed.symbol}`);
   144→      console.log(`  Entry: ${closed.entryPriceSol} SOL`);
   145→      console.log(`  Exit: ${currentPriceSol} SOL`);
   146→      console.log(`  P&L: ${closed.pnlPercent?.toFixed(2)}% (${closed.pnlSol?.toFixed(4)} SOL)`);
   147→    }
   148→    return closed;
   149→  }
   150→}
   151→
   152→// Factory function
   153→export function createTrigger(config: TriggerConfig): TradeTrigger {
   154→  return new TradeTrigger(config);
   155→}
   156→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
